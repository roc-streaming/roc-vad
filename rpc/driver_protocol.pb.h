// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: driver_protocol.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_driver_5fprotocol_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_driver_5fprotocol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_driver_5fprotocol_2eproto;
namespace rvpb {
class RvDeviceEncoding;
struct RvDeviceEncodingDefaultTypeInternal;
extern RvDeviceEncodingDefaultTypeInternal _RvDeviceEncoding_default_instance_;
class RvDeviceInfo;
struct RvDeviceInfoDefaultTypeInternal;
extern RvDeviceInfoDefaultTypeInternal _RvDeviceInfo_default_instance_;
class RvDeviceList;
struct RvDeviceListDefaultTypeInternal;
extern RvDeviceListDefaultTypeInternal _RvDeviceList_default_instance_;
class RvDeviceSelector;
struct RvDeviceSelectorDefaultTypeInternal;
extern RvDeviceSelectorDefaultTypeInternal _RvDeviceSelector_default_instance_;
class RvDriverInfo;
struct RvDriverInfoDefaultTypeInternal;
extern RvDriverInfoDefaultTypeInternal _RvDriverInfo_default_instance_;
class RvEndpointInfo;
struct RvEndpointInfoDefaultTypeInternal;
extern RvEndpointInfoDefaultTypeInternal _RvEndpointInfo_default_instance_;
class RvEndpointRequest;
struct RvEndpointRequestDefaultTypeInternal;
extern RvEndpointRequestDefaultTypeInternal _RvEndpointRequest_default_instance_;
class RvLogEntry;
struct RvLogEntryDefaultTypeInternal;
extern RvLogEntryDefaultTypeInternal _RvLogEntry_default_instance_;
class RvNone;
struct RvNoneDefaultTypeInternal;
extern RvNoneDefaultTypeInternal _RvNone_default_instance_;
class RvPacketEncoding;
struct RvPacketEncodingDefaultTypeInternal;
extern RvPacketEncodingDefaultTypeInternal _RvPacketEncoding_default_instance_;
class RvReceiverConfig;
struct RvReceiverConfigDefaultTypeInternal;
extern RvReceiverConfigDefaultTypeInternal _RvReceiverConfig_default_instance_;
class RvSenderConfig;
struct RvSenderConfigDefaultTypeInternal;
extern RvSenderConfigDefaultTypeInternal _RvSenderConfig_default_instance_;
class RvToggleRequest;
struct RvToggleRequestDefaultTypeInternal;
extern RvToggleRequestDefaultTypeInternal _RvToggleRequest_default_instance_;
}  // namespace rvpb
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace rvpb {
enum RvLogEntry_Level : int {
  RvLogEntry_Level_CRIT = 0,
  RvLogEntry_Level_ERROR = 1,
  RvLogEntry_Level_WARN = 2,
  RvLogEntry_Level_INFO = 3,
  RvLogEntry_Level_DEBUG = 4,
  RvLogEntry_Level_TRACE = 5,
  RvLogEntry_Level_RvLogEntry_Level_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvLogEntry_Level_RvLogEntry_Level_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvLogEntry_Level_IsValid(int value);
extern const uint32_t RvLogEntry_Level_internal_data_[];
constexpr RvLogEntry_Level RvLogEntry_Level_Level_MIN = static_cast<RvLogEntry_Level>(0);
constexpr RvLogEntry_Level RvLogEntry_Level_Level_MAX = static_cast<RvLogEntry_Level>(5);
constexpr int RvLogEntry_Level_Level_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
RvLogEntry_Level_descriptor();
template <typename T>
const std::string& RvLogEntry_Level_Name(T value) {
  static_assert(std::is_same<T, RvLogEntry_Level>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Level_Name().");
  return RvLogEntry_Level_Name(static_cast<RvLogEntry_Level>(value));
}
template <>
inline const std::string& RvLogEntry_Level_Name(RvLogEntry_Level value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvLogEntry_Level_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool RvLogEntry_Level_Parse(absl::string_view name, RvLogEntry_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvLogEntry_Level>(
      RvLogEntry_Level_descriptor(), name, value);
}
enum RvDeviceType : int {
  RV_DEVICE_TYPE_SENDER = 0,
  RV_DEVICE_TYPE_RECEIVER = 1,
  RvDeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvDeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvDeviceType_IsValid(int value);
extern const uint32_t RvDeviceType_internal_data_[];
constexpr RvDeviceType RvDeviceType_MIN = static_cast<RvDeviceType>(0);
constexpr RvDeviceType RvDeviceType_MAX = static_cast<RvDeviceType>(1);
constexpr int RvDeviceType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
RvDeviceType_descriptor();
template <typename T>
const std::string& RvDeviceType_Name(T value) {
  static_assert(std::is_same<T, RvDeviceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvDeviceType_Name().");
  return RvDeviceType_Name(static_cast<RvDeviceType>(value));
}
template <>
inline const std::string& RvDeviceType_Name(RvDeviceType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvDeviceType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool RvDeviceType_Parse(absl::string_view name, RvDeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvDeviceType>(
      RvDeviceType_descriptor(), name, value);
}
enum RvInterface : int {
  RV_INTERFACE_CONSOLIDATED = 0,
  RV_INTERFACE_AUDIO_SOURCE = 1,
  RV_INTERFACE_AUDIO_REPAIR = 2,
  RV_INTERFACE_AUDIO_CONTROL = 3,
  RvInterface_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvInterface_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvInterface_IsValid(int value);
extern const uint32_t RvInterface_internal_data_[];
constexpr RvInterface RvInterface_MIN = static_cast<RvInterface>(0);
constexpr RvInterface RvInterface_MAX = static_cast<RvInterface>(3);
constexpr int RvInterface_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RvInterface_descriptor();
template <typename T>
const std::string& RvInterface_Name(T value) {
  static_assert(std::is_same<T, RvInterface>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvInterface_Name().");
  return RvInterface_Name(static_cast<RvInterface>(value));
}
template <>
inline const std::string& RvInterface_Name(RvInterface value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvInterface_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RvInterface_Parse(absl::string_view name, RvInterface* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvInterface>(
      RvInterface_descriptor(), name, value);
}
enum RvSampleFormat : int {
  ROC_FORMAT_PCM_SINT16 = 0,
  RvSampleFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvSampleFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvSampleFormat_IsValid(int value);
extern const uint32_t RvSampleFormat_internal_data_[];
constexpr RvSampleFormat RvSampleFormat_MIN = static_cast<RvSampleFormat>(0);
constexpr RvSampleFormat RvSampleFormat_MAX = static_cast<RvSampleFormat>(0);
constexpr int RvSampleFormat_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
RvSampleFormat_descriptor();
template <typename T>
const std::string& RvSampleFormat_Name(T value) {
  static_assert(std::is_same<T, RvSampleFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvSampleFormat_Name().");
  return RvSampleFormat_Name(static_cast<RvSampleFormat>(value));
}
template <>
inline const std::string& RvSampleFormat_Name(RvSampleFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvSampleFormat_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool RvSampleFormat_Parse(absl::string_view name, RvSampleFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvSampleFormat>(
      RvSampleFormat_descriptor(), name, value);
}
enum RvChannelLayout : int {
  RV_CHANNEL_LAYOUT_MONO = 0,
  RV_CHANNEL_LAYOUT_STEREO = 1,
  RV_CHANNEL_LAYOUT_MULTITRACK = 2,
  RvChannelLayout_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvChannelLayout_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvChannelLayout_IsValid(int value);
extern const uint32_t RvChannelLayout_internal_data_[];
constexpr RvChannelLayout RvChannelLayout_MIN = static_cast<RvChannelLayout>(0);
constexpr RvChannelLayout RvChannelLayout_MAX = static_cast<RvChannelLayout>(2);
constexpr int RvChannelLayout_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RvChannelLayout_descriptor();
template <typename T>
const std::string& RvChannelLayout_Name(T value) {
  static_assert(std::is_same<T, RvChannelLayout>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvChannelLayout_Name().");
  return RvChannelLayout_Name(static_cast<RvChannelLayout>(value));
}
template <>
inline const std::string& RvChannelLayout_Name(RvChannelLayout value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvChannelLayout_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RvChannelLayout_Parse(absl::string_view name, RvChannelLayout* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvChannelLayout>(
      RvChannelLayout_descriptor(), name, value);
}
enum RvFecEncoding : int {
  RV_FEC_ENCODING_DISABLE = 0,
  RV_FEC_ENCODING_DEFAULT = 1,
  RV_FEC_ENCODING_RS8M = 2,
  RV_FEC_ENCODING_LDPC_STAIRCASE = 3,
  RvFecEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvFecEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvFecEncoding_IsValid(int value);
extern const uint32_t RvFecEncoding_internal_data_[];
constexpr RvFecEncoding RvFecEncoding_MIN = static_cast<RvFecEncoding>(0);
constexpr RvFecEncoding RvFecEncoding_MAX = static_cast<RvFecEncoding>(3);
constexpr int RvFecEncoding_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RvFecEncoding_descriptor();
template <typename T>
const std::string& RvFecEncoding_Name(T value) {
  static_assert(std::is_same<T, RvFecEncoding>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvFecEncoding_Name().");
  return RvFecEncoding_Name(static_cast<RvFecEncoding>(value));
}
template <>
inline const std::string& RvFecEncoding_Name(RvFecEncoding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvFecEncoding_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RvFecEncoding_Parse(absl::string_view name, RvFecEncoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvFecEncoding>(
      RvFecEncoding_descriptor(), name, value);
}
enum RvLatencyTunerBackend : int {
  RV_LATENCY_TUNER_BACKEND_DEFAULT = 0,
  RV_LATENCY_TUNER_BACKEND_NIQ = 2,
  RvLatencyTunerBackend_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvLatencyTunerBackend_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvLatencyTunerBackend_IsValid(int value);
extern const uint32_t RvLatencyTunerBackend_internal_data_[];
constexpr RvLatencyTunerBackend RvLatencyTunerBackend_MIN = static_cast<RvLatencyTunerBackend>(0);
constexpr RvLatencyTunerBackend RvLatencyTunerBackend_MAX = static_cast<RvLatencyTunerBackend>(2);
constexpr int RvLatencyTunerBackend_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RvLatencyTunerBackend_descriptor();
template <typename T>
const std::string& RvLatencyTunerBackend_Name(T value) {
  static_assert(std::is_same<T, RvLatencyTunerBackend>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvLatencyTunerBackend_Name().");
  return RvLatencyTunerBackend_Name(static_cast<RvLatencyTunerBackend>(value));
}
template <>
inline const std::string& RvLatencyTunerBackend_Name(RvLatencyTunerBackend value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvLatencyTunerBackend_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RvLatencyTunerBackend_Parse(absl::string_view name, RvLatencyTunerBackend* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvLatencyTunerBackend>(
      RvLatencyTunerBackend_descriptor(), name, value);
}
enum RvLatencyTunerProfile : int {
  RV_LATENCY_TUNER_PROFILE_DEFAULT = 0,
  RV_LATENCY_TUNER_PROFILE_INTACT = 1,
  RV_LATENCY_TUNER_PROFILE_RESPONSIVE = 2,
  RV_LATENCY_TUNER_PROFILE_GRADUAL = 3,
  RvLatencyTunerProfile_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvLatencyTunerProfile_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvLatencyTunerProfile_IsValid(int value);
extern const uint32_t RvLatencyTunerProfile_internal_data_[];
constexpr RvLatencyTunerProfile RvLatencyTunerProfile_MIN = static_cast<RvLatencyTunerProfile>(0);
constexpr RvLatencyTunerProfile RvLatencyTunerProfile_MAX = static_cast<RvLatencyTunerProfile>(3);
constexpr int RvLatencyTunerProfile_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RvLatencyTunerProfile_descriptor();
template <typename T>
const std::string& RvLatencyTunerProfile_Name(T value) {
  static_assert(std::is_same<T, RvLatencyTunerProfile>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvLatencyTunerProfile_Name().");
  return RvLatencyTunerProfile_Name(static_cast<RvLatencyTunerProfile>(value));
}
template <>
inline const std::string& RvLatencyTunerProfile_Name(RvLatencyTunerProfile value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvLatencyTunerProfile_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RvLatencyTunerProfile_Parse(absl::string_view name, RvLatencyTunerProfile* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvLatencyTunerProfile>(
      RvLatencyTunerProfile_descriptor(), name, value);
}
enum RvResamplerBackend : int {
  RV_RESAMPLER_BACKEND_DEFAULT = 0,
  RV_RESAMPLER_BACKEND_BUILTIN = 1,
  RV_RESAMPLER_BACKEND_SPEEX = 2,
  RV_RESAMPLER_BACKEND_SPEEXDEC = 3,
  RvResamplerBackend_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvResamplerBackend_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvResamplerBackend_IsValid(int value);
extern const uint32_t RvResamplerBackend_internal_data_[];
constexpr RvResamplerBackend RvResamplerBackend_MIN = static_cast<RvResamplerBackend>(0);
constexpr RvResamplerBackend RvResamplerBackend_MAX = static_cast<RvResamplerBackend>(3);
constexpr int RvResamplerBackend_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RvResamplerBackend_descriptor();
template <typename T>
const std::string& RvResamplerBackend_Name(T value) {
  static_assert(std::is_same<T, RvResamplerBackend>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvResamplerBackend_Name().");
  return RvResamplerBackend_Name(static_cast<RvResamplerBackend>(value));
}
template <>
inline const std::string& RvResamplerBackend_Name(RvResamplerBackend value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvResamplerBackend_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RvResamplerBackend_Parse(absl::string_view name, RvResamplerBackend* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvResamplerBackend>(
      RvResamplerBackend_descriptor(), name, value);
}
enum RvResamplerProfile : int {
  RV_RESAMPLER_PROFILE_DEFAULT = 0,
  RV_RESAMPLER_PROFILE_HIGH = 1,
  RV_RESAMPLER_PROFILE_MEDIUM = 2,
  RV_RESAMPLER_PROFILE_LOW = 3,
  RvResamplerProfile_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RvResamplerProfile_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RvResamplerProfile_IsValid(int value);
extern const uint32_t RvResamplerProfile_internal_data_[];
constexpr RvResamplerProfile RvResamplerProfile_MIN = static_cast<RvResamplerProfile>(0);
constexpr RvResamplerProfile RvResamplerProfile_MAX = static_cast<RvResamplerProfile>(3);
constexpr int RvResamplerProfile_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RvResamplerProfile_descriptor();
template <typename T>
const std::string& RvResamplerProfile_Name(T value) {
  static_assert(std::is_same<T, RvResamplerProfile>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RvResamplerProfile_Name().");
  return RvResamplerProfile_Name(static_cast<RvResamplerProfile>(value));
}
template <>
inline const std::string& RvResamplerProfile_Name(RvResamplerProfile value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RvResamplerProfile_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RvResamplerProfile_Parse(absl::string_view name, RvResamplerProfile* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RvResamplerProfile>(
      RvResamplerProfile_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RvPacketEncoding final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvPacketEncoding) */ {
 public:
  inline RvPacketEncoding() : RvPacketEncoding(nullptr) {}
  ~RvPacketEncoding() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvPacketEncoding(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvPacketEncoding(const RvPacketEncoding& from) : RvPacketEncoding(nullptr, from) {}
  inline RvPacketEncoding(RvPacketEncoding&& from) noexcept
      : RvPacketEncoding(nullptr, std::move(from)) {}
  inline RvPacketEncoding& operator=(const RvPacketEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvPacketEncoding& operator=(RvPacketEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvPacketEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvPacketEncoding* internal_default_instance() {
    return reinterpret_cast<const RvPacketEncoding*>(
        &_RvPacketEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RvPacketEncoding& a, RvPacketEncoding& b) { a.Swap(&b); }
  inline void Swap(RvPacketEncoding* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvPacketEncoding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvPacketEncoding* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvPacketEncoding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvPacketEncoding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvPacketEncoding& from) { RvPacketEncoding::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvPacketEncoding* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvPacketEncoding"; }

 protected:
  explicit RvPacketEncoding(::google::protobuf::Arena* arena);
  RvPacketEncoding(::google::protobuf::Arena* arena, const RvPacketEncoding& from);
  RvPacketEncoding(::google::protobuf::Arena* arena, RvPacketEncoding&& from) noexcept
      : RvPacketEncoding(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEncodingIdFieldNumber = 1,
    kSampleRateFieldNumber = 2,
    kSampleFormatFieldNumber = 3,
    kChannelLayoutFieldNumber = 4,
    kTrackCountFieldNumber = 5,
  };
  // uint32 encoding_id = 1;
  void clear_encoding_id() ;
  ::uint32_t encoding_id() const;
  void set_encoding_id(::uint32_t value);

  private:
  ::uint32_t _internal_encoding_id() const;
  void _internal_set_encoding_id(::uint32_t value);

  public:
  // uint32 sample_rate = 2;
  void clear_sample_rate() ;
  ::uint32_t sample_rate() const;
  void set_sample_rate(::uint32_t value);

  private:
  ::uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::uint32_t value);

  public:
  // .rvpb.RvSampleFormat sample_format = 3;
  void clear_sample_format() ;
  ::rvpb::RvSampleFormat sample_format() const;
  void set_sample_format(::rvpb::RvSampleFormat value);

  private:
  ::rvpb::RvSampleFormat _internal_sample_format() const;
  void _internal_set_sample_format(::rvpb::RvSampleFormat value);

  public:
  // .rvpb.RvChannelLayout channel_layout = 4;
  void clear_channel_layout() ;
  ::rvpb::RvChannelLayout channel_layout() const;
  void set_channel_layout(::rvpb::RvChannelLayout value);

  private:
  ::rvpb::RvChannelLayout _internal_channel_layout() const;
  void _internal_set_channel_layout(::rvpb::RvChannelLayout value);

  public:
  // optional uint32 track_count = 5;
  bool has_track_count() const;
  void clear_track_count() ;
  ::uint32_t track_count() const;
  void set_track_count(::uint32_t value);

  private:
  ::uint32_t _internal_track_count() const;
  void _internal_set_track_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvPacketEncoding)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t encoding_id_;
    ::uint32_t sample_rate_;
    int sample_format_;
    int channel_layout_;
    ::uint32_t track_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvNone final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:rvpb.RvNone) */ {
 public:
  inline RvNone() : RvNone(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvNone(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvNone(const RvNone& from) : RvNone(nullptr, from) {}
  inline RvNone(RvNone&& from) noexcept
      : RvNone(nullptr, std::move(from)) {}
  inline RvNone& operator=(const RvNone& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvNone& operator=(RvNone&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvNone& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvNone* internal_default_instance() {
    return reinterpret_cast<const RvNone*>(
        &_RvNone_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RvNone& a, RvNone& b) { a.Swap(&b); }
  inline void Swap(RvNone* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvNone* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvNone* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<RvNone>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RvNone& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RvNone& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvNone"; }

 protected:
  explicit RvNone(::google::protobuf::Arena* arena);
  RvNone(::google::protobuf::Arena* arena, const RvNone& from);
  RvNone(::google::protobuf::Arena* arena, RvNone&& from) noexcept
      : RvNone(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:rvpb.RvNone)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvEndpointInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvEndpointInfo) */ {
 public:
  inline RvEndpointInfo() : RvEndpointInfo(nullptr) {}
  ~RvEndpointInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvEndpointInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvEndpointInfo(const RvEndpointInfo& from) : RvEndpointInfo(nullptr, from) {}
  inline RvEndpointInfo(RvEndpointInfo&& from) noexcept
      : RvEndpointInfo(nullptr, std::move(from)) {}
  inline RvEndpointInfo& operator=(const RvEndpointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvEndpointInfo& operator=(RvEndpointInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvEndpointInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvEndpointInfo* internal_default_instance() {
    return reinterpret_cast<const RvEndpointInfo*>(
        &_RvEndpointInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RvEndpointInfo& a, RvEndpointInfo& b) { a.Swap(&b); }
  inline void Swap(RvEndpointInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvEndpointInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvEndpointInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvEndpointInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvEndpointInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvEndpointInfo& from) { RvEndpointInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvEndpointInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvEndpointInfo"; }

 protected:
  explicit RvEndpointInfo(::google::protobuf::Arena* arena);
  RvEndpointInfo(::google::protobuf::Arena* arena, const RvEndpointInfo& from);
  RvEndpointInfo(::google::protobuf::Arena* arena, RvEndpointInfo&& from) noexcept
      : RvEndpointInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUriFieldNumber = 3,
    kSlotFieldNumber = 1,
    kInterfaceFieldNumber = 2,
  };
  // string uri = 3;
  void clear_uri() ;
  const std::string& uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri(Arg_&& arg, Args_... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* value);

  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(
      const std::string& value);
  std::string* _internal_mutable_uri();

  public:
  // optional uint32 slot = 1;
  bool has_slot() const;
  void clear_slot() ;
  ::uint32_t slot() const;
  void set_slot(::uint32_t value);

  private:
  ::uint32_t _internal_slot() const;
  void _internal_set_slot(::uint32_t value);

  public:
  // .rvpb.RvInterface interface = 2;
  void clear_interface() ;
  ::rvpb::RvInterface interface() const;
  void set_interface(::rvpb::RvInterface value);

  private:
  ::rvpb::RvInterface _internal_interface() const;
  void _internal_set_interface(::rvpb::RvInterface value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvEndpointInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
    ::uint32_t slot_;
    int interface_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvDriverInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvDriverInfo) */ {
 public:
  inline RvDriverInfo() : RvDriverInfo(nullptr) {}
  ~RvDriverInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvDriverInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvDriverInfo(const RvDriverInfo& from) : RvDriverInfo(nullptr, from) {}
  inline RvDriverInfo(RvDriverInfo&& from) noexcept
      : RvDriverInfo(nullptr, std::move(from)) {}
  inline RvDriverInfo& operator=(const RvDriverInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvDriverInfo& operator=(RvDriverInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvDriverInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvDriverInfo* internal_default_instance() {
    return reinterpret_cast<const RvDriverInfo*>(
        &_RvDriverInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RvDriverInfo& a, RvDriverInfo& b) { a.Swap(&b); }
  inline void Swap(RvDriverInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvDriverInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvDriverInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvDriverInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvDriverInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvDriverInfo& from) { RvDriverInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvDriverInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvDriverInfo"; }

 protected:
  explicit RvDriverInfo(::google::protobuf::Arena* arena);
  RvDriverInfo(::google::protobuf::Arena* arena, const RvDriverInfo& from);
  RvDriverInfo(::google::protobuf::Arena* arena, RvDriverInfo&& from) noexcept
      : RvDriverInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionFieldNumber = 1,
    kCommitFieldNumber = 2,
  };
  // string version = 1;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string commit = 2;
  void clear_commit() ;
  const std::string& commit() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commit(Arg_&& arg, Args_... args);
  std::string* mutable_commit();
  PROTOBUF_NODISCARD std::string* release_commit();
  void set_allocated_commit(std::string* value);

  private:
  const std::string& _internal_commit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commit(
      const std::string& value);
  std::string* _internal_mutable_commit();

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvDriverInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr commit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvDeviceSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvDeviceSelector) */ {
 public:
  inline RvDeviceSelector() : RvDeviceSelector(nullptr) {}
  ~RvDeviceSelector() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvDeviceSelector(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvDeviceSelector(const RvDeviceSelector& from) : RvDeviceSelector(nullptr, from) {}
  inline RvDeviceSelector(RvDeviceSelector&& from) noexcept
      : RvDeviceSelector(nullptr, std::move(from)) {}
  inline RvDeviceSelector& operator=(const RvDeviceSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvDeviceSelector& operator=(RvDeviceSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvDeviceSelector& default_instance() {
    return *internal_default_instance();
  }
  enum SelectorCase {
    kIndex = 1,
    kUid = 2,
    SELECTOR_NOT_SET = 0,
  };
  static inline const RvDeviceSelector* internal_default_instance() {
    return reinterpret_cast<const RvDeviceSelector*>(
        &_RvDeviceSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(RvDeviceSelector& a, RvDeviceSelector& b) { a.Swap(&b); }
  inline void Swap(RvDeviceSelector* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvDeviceSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvDeviceSelector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvDeviceSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvDeviceSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvDeviceSelector& from) { RvDeviceSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvDeviceSelector* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvDeviceSelector"; }

 protected:
  explicit RvDeviceSelector(::google::protobuf::Arena* arena);
  RvDeviceSelector(::google::protobuf::Arena* arena, const RvDeviceSelector& from);
  RvDeviceSelector(::google::protobuf::Arena* arena, RvDeviceSelector&& from) noexcept
      : RvDeviceSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // uint32 index = 1;
  bool has_index() const;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // string uid = 2;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  void clear_Selector();
  SelectorCase Selector_case() const;
  // @@protoc_insertion_point(class_scope:rvpb.RvDeviceSelector)
 private:
  class _Internal;
  void set_has_index();
  void set_has_uid();
  inline bool has_Selector() const;
  inline void clear_has_Selector();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    union SelectorUnion {
      constexpr SelectorUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t index_;
      ::google::protobuf::internal::ArenaStringPtr uid_;
    } Selector_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvToggleRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvToggleRequest) */ {
 public:
  inline RvToggleRequest() : RvToggleRequest(nullptr) {}
  ~RvToggleRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvToggleRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvToggleRequest(const RvToggleRequest& from) : RvToggleRequest(nullptr, from) {}
  inline RvToggleRequest(RvToggleRequest&& from) noexcept
      : RvToggleRequest(nullptr, std::move(from)) {}
  inline RvToggleRequest& operator=(const RvToggleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvToggleRequest& operator=(RvToggleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvToggleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvToggleRequest* internal_default_instance() {
    return reinterpret_cast<const RvToggleRequest*>(
        &_RvToggleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RvToggleRequest& a, RvToggleRequest& b) { a.Swap(&b); }
  inline void Swap(RvToggleRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvToggleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvToggleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvToggleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvToggleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvToggleRequest& from) { RvToggleRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvToggleRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvToggleRequest"; }

 protected:
  explicit RvToggleRequest(::google::protobuf::Arena* arena);
  RvToggleRequest(::google::protobuf::Arena* arena, const RvToggleRequest& from);
  RvToggleRequest(::google::protobuf::Arena* arena, RvToggleRequest&& from) noexcept
      : RvToggleRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // .rvpb.RvDeviceSelector device = 1;
  bool has_device() const;
  void clear_device() ;
  const ::rvpb::RvDeviceSelector& device() const;
  PROTOBUF_NODISCARD ::rvpb::RvDeviceSelector* release_device();
  ::rvpb::RvDeviceSelector* mutable_device();
  void set_allocated_device(::rvpb::RvDeviceSelector* value);
  void unsafe_arena_set_allocated_device(::rvpb::RvDeviceSelector* value);
  ::rvpb::RvDeviceSelector* unsafe_arena_release_device();

  private:
  const ::rvpb::RvDeviceSelector& _internal_device() const;
  ::rvpb::RvDeviceSelector* _internal_mutable_device();

  public:
  // bool enabled = 2;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvToggleRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::rvpb::RvDeviceSelector* device_;
    bool enabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvSenderConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvSenderConfig) */ {
 public:
  inline RvSenderConfig() : RvSenderConfig(nullptr) {}
  ~RvSenderConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvSenderConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvSenderConfig(const RvSenderConfig& from) : RvSenderConfig(nullptr, from) {}
  inline RvSenderConfig(RvSenderConfig&& from) noexcept
      : RvSenderConfig(nullptr, std::move(from)) {}
  inline RvSenderConfig& operator=(const RvSenderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvSenderConfig& operator=(RvSenderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvSenderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvSenderConfig* internal_default_instance() {
    return reinterpret_cast<const RvSenderConfig*>(
        &_RvSenderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RvSenderConfig& a, RvSenderConfig& b) { a.Swap(&b); }
  inline void Swap(RvSenderConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvSenderConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvSenderConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvSenderConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvSenderConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvSenderConfig& from) { RvSenderConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvSenderConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvSenderConfig"; }

 protected:
  explicit RvSenderConfig(::google::protobuf::Arena* arena);
  RvSenderConfig(::google::protobuf::Arena* arena, const RvSenderConfig& from);
  RvSenderConfig(::google::protobuf::Arena* arena, RvSenderConfig&& from) noexcept
      : RvSenderConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPacketEncodingFieldNumber = 1,
    kPacketLengthFieldNumber = 2,
    kTargetLatencyFieldNumber = 11,
    kLatencyToleranceFieldNumber = 13,
    kPacketInterleavingFieldNumber = 3,
    kFecEncodingFieldNumber = 4,
    kFecBlockSourcePacketsFieldNumber = 5,
    kFecBlockRepairPacketsFieldNumber = 6,
    kLatencyTunerBackendFieldNumber = 7,
    kLatencyTunerProfileFieldNumber = 8,
    kResamplerBackendFieldNumber = 9,
    kResamplerProfileFieldNumber = 10,
  };
  // optional .rvpb.RvPacketEncoding packet_encoding = 1;
  bool has_packet_encoding() const;
  void clear_packet_encoding() ;
  const ::rvpb::RvPacketEncoding& packet_encoding() const;
  PROTOBUF_NODISCARD ::rvpb::RvPacketEncoding* release_packet_encoding();
  ::rvpb::RvPacketEncoding* mutable_packet_encoding();
  void set_allocated_packet_encoding(::rvpb::RvPacketEncoding* value);
  void unsafe_arena_set_allocated_packet_encoding(::rvpb::RvPacketEncoding* value);
  ::rvpb::RvPacketEncoding* unsafe_arena_release_packet_encoding();

  private:
  const ::rvpb::RvPacketEncoding& _internal_packet_encoding() const;
  ::rvpb::RvPacketEncoding* _internal_mutable_packet_encoding();

  public:
  // optional .google.protobuf.Duration packet_length = 2;
  bool has_packet_length() const;
  void clear_packet_length() ;
  const ::google::protobuf::Duration& packet_length() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_packet_length();
  ::google::protobuf::Duration* mutable_packet_length();
  void set_allocated_packet_length(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_packet_length(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_packet_length();

  private:
  const ::google::protobuf::Duration& _internal_packet_length() const;
  ::google::protobuf::Duration* _internal_mutable_packet_length();

  public:
  // optional .google.protobuf.Duration target_latency = 11;
  bool has_target_latency() const;
  void clear_target_latency() ;
  const ::google::protobuf::Duration& target_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_target_latency();
  ::google::protobuf::Duration* mutable_target_latency();
  void set_allocated_target_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_target_latency();

  private:
  const ::google::protobuf::Duration& _internal_target_latency() const;
  ::google::protobuf::Duration* _internal_mutable_target_latency();

  public:
  // optional .google.protobuf.Duration latency_tolerance = 13;
  bool has_latency_tolerance() const;
  void clear_latency_tolerance() ;
  const ::google::protobuf::Duration& latency_tolerance() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_latency_tolerance();
  ::google::protobuf::Duration* mutable_latency_tolerance();
  void set_allocated_latency_tolerance(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_latency_tolerance(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_latency_tolerance();

  private:
  const ::google::protobuf::Duration& _internal_latency_tolerance() const;
  ::google::protobuf::Duration* _internal_mutable_latency_tolerance();

  public:
  // optional bool packet_interleaving = 3;
  bool has_packet_interleaving() const;
  void clear_packet_interleaving() ;
  bool packet_interleaving() const;
  void set_packet_interleaving(bool value);

  private:
  bool _internal_packet_interleaving() const;
  void _internal_set_packet_interleaving(bool value);

  public:
  // optional .rvpb.RvFecEncoding fec_encoding = 4;
  bool has_fec_encoding() const;
  void clear_fec_encoding() ;
  ::rvpb::RvFecEncoding fec_encoding() const;
  void set_fec_encoding(::rvpb::RvFecEncoding value);

  private:
  ::rvpb::RvFecEncoding _internal_fec_encoding() const;
  void _internal_set_fec_encoding(::rvpb::RvFecEncoding value);

  public:
  // optional uint32 fec_block_source_packets = 5;
  bool has_fec_block_source_packets() const;
  void clear_fec_block_source_packets() ;
  ::uint32_t fec_block_source_packets() const;
  void set_fec_block_source_packets(::uint32_t value);

  private:
  ::uint32_t _internal_fec_block_source_packets() const;
  void _internal_set_fec_block_source_packets(::uint32_t value);

  public:
  // optional uint32 fec_block_repair_packets = 6;
  bool has_fec_block_repair_packets() const;
  void clear_fec_block_repair_packets() ;
  ::uint32_t fec_block_repair_packets() const;
  void set_fec_block_repair_packets(::uint32_t value);

  private:
  ::uint32_t _internal_fec_block_repair_packets() const;
  void _internal_set_fec_block_repair_packets(::uint32_t value);

  public:
  // optional .rvpb.RvLatencyTunerBackend latency_tuner_backend = 7;
  bool has_latency_tuner_backend() const;
  void clear_latency_tuner_backend() ;
  ::rvpb::RvLatencyTunerBackend latency_tuner_backend() const;
  void set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value);

  private:
  ::rvpb::RvLatencyTunerBackend _internal_latency_tuner_backend() const;
  void _internal_set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value);

  public:
  // optional .rvpb.RvLatencyTunerProfile latency_tuner_profile = 8;
  bool has_latency_tuner_profile() const;
  void clear_latency_tuner_profile() ;
  ::rvpb::RvLatencyTunerProfile latency_tuner_profile() const;
  void set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value);

  private:
  ::rvpb::RvLatencyTunerProfile _internal_latency_tuner_profile() const;
  void _internal_set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value);

  public:
  // optional .rvpb.RvResamplerBackend resampler_backend = 9;
  bool has_resampler_backend() const;
  void clear_resampler_backend() ;
  ::rvpb::RvResamplerBackend resampler_backend() const;
  void set_resampler_backend(::rvpb::RvResamplerBackend value);

  private:
  ::rvpb::RvResamplerBackend _internal_resampler_backend() const;
  void _internal_set_resampler_backend(::rvpb::RvResamplerBackend value);

  public:
  // optional .rvpb.RvResamplerProfile resampler_profile = 10;
  bool has_resampler_profile() const;
  void clear_resampler_profile() ;
  ::rvpb::RvResamplerProfile resampler_profile() const;
  void set_resampler_profile(::rvpb::RvResamplerProfile value);

  private:
  ::rvpb::RvResamplerProfile _internal_resampler_profile() const;
  void _internal_set_resampler_profile(::rvpb::RvResamplerProfile value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvSenderConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::rvpb::RvPacketEncoding* packet_encoding_;
    ::google::protobuf::Duration* packet_length_;
    ::google::protobuf::Duration* target_latency_;
    ::google::protobuf::Duration* latency_tolerance_;
    bool packet_interleaving_;
    int fec_encoding_;
    ::uint32_t fec_block_source_packets_;
    ::uint32_t fec_block_repair_packets_;
    int latency_tuner_backend_;
    int latency_tuner_profile_;
    int resampler_backend_;
    int resampler_profile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvReceiverConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvReceiverConfig) */ {
 public:
  inline RvReceiverConfig() : RvReceiverConfig(nullptr) {}
  ~RvReceiverConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvReceiverConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvReceiverConfig(const RvReceiverConfig& from) : RvReceiverConfig(nullptr, from) {}
  inline RvReceiverConfig(RvReceiverConfig&& from) noexcept
      : RvReceiverConfig(nullptr, std::move(from)) {}
  inline RvReceiverConfig& operator=(const RvReceiverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvReceiverConfig& operator=(RvReceiverConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvReceiverConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvReceiverConfig* internal_default_instance() {
    return reinterpret_cast<const RvReceiverConfig*>(
        &_RvReceiverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(RvReceiverConfig& a, RvReceiverConfig& b) { a.Swap(&b); }
  inline void Swap(RvReceiverConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvReceiverConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvReceiverConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvReceiverConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvReceiverConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvReceiverConfig& from) { RvReceiverConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvReceiverConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvReceiverConfig"; }

 protected:
  explicit RvReceiverConfig(::google::protobuf::Arena* arena);
  RvReceiverConfig(::google::protobuf::Arena* arena, const RvReceiverConfig& from);
  RvReceiverConfig(::google::protobuf::Arena* arena, RvReceiverConfig&& from) noexcept
      : RvReceiverConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPacketEncodingsFieldNumber = 1,
    kTargetLatencyFieldNumber = 6,
    kNoPlaybackTimeoutFieldNumber = 9,
    kChoppyPlaybackTimeoutFieldNumber = 10,
    kLatencyToleranceFieldNumber = 11,
    kLatencyTunerBackendFieldNumber = 2,
    kLatencyTunerProfileFieldNumber = 3,
    kResamplerBackendFieldNumber = 4,
    kResamplerProfileFieldNumber = 5,
  };
  // repeated .rvpb.RvPacketEncoding packet_encodings = 1;
  int packet_encodings_size() const;
  private:
  int _internal_packet_encodings_size() const;

  public:
  void clear_packet_encodings() ;
  ::rvpb::RvPacketEncoding* mutable_packet_encodings(int index);
  ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>* mutable_packet_encodings();

  private:
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>& _internal_packet_encodings() const;
  ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>* _internal_mutable_packet_encodings();
  public:
  const ::rvpb::RvPacketEncoding& packet_encodings(int index) const;
  ::rvpb::RvPacketEncoding* add_packet_encodings();
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>& packet_encodings() const;
  // optional .google.protobuf.Duration target_latency = 6;
  bool has_target_latency() const;
  void clear_target_latency() ;
  const ::google::protobuf::Duration& target_latency() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_target_latency();
  ::google::protobuf::Duration* mutable_target_latency();
  void set_allocated_target_latency(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_target_latency();

  private:
  const ::google::protobuf::Duration& _internal_target_latency() const;
  ::google::protobuf::Duration* _internal_mutable_target_latency();

  public:
  // optional .google.protobuf.Duration no_playback_timeout = 9;
  bool has_no_playback_timeout() const;
  void clear_no_playback_timeout() ;
  const ::google::protobuf::Duration& no_playback_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_no_playback_timeout();
  ::google::protobuf::Duration* mutable_no_playback_timeout();
  void set_allocated_no_playback_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_no_playback_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_no_playback_timeout();

  private:
  const ::google::protobuf::Duration& _internal_no_playback_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_no_playback_timeout();

  public:
  // optional .google.protobuf.Duration choppy_playback_timeout = 10;
  bool has_choppy_playback_timeout() const;
  void clear_choppy_playback_timeout() ;
  const ::google::protobuf::Duration& choppy_playback_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_choppy_playback_timeout();
  ::google::protobuf::Duration* mutable_choppy_playback_timeout();
  void set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_choppy_playback_timeout();

  private:
  const ::google::protobuf::Duration& _internal_choppy_playback_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_choppy_playback_timeout();

  public:
  // optional .google.protobuf.Duration latency_tolerance = 11;
  bool has_latency_tolerance() const;
  void clear_latency_tolerance() ;
  const ::google::protobuf::Duration& latency_tolerance() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_latency_tolerance();
  ::google::protobuf::Duration* mutable_latency_tolerance();
  void set_allocated_latency_tolerance(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_latency_tolerance(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_latency_tolerance();

  private:
  const ::google::protobuf::Duration& _internal_latency_tolerance() const;
  ::google::protobuf::Duration* _internal_mutable_latency_tolerance();

  public:
  // optional .rvpb.RvLatencyTunerBackend latency_tuner_backend = 2;
  bool has_latency_tuner_backend() const;
  void clear_latency_tuner_backend() ;
  ::rvpb::RvLatencyTunerBackend latency_tuner_backend() const;
  void set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value);

  private:
  ::rvpb::RvLatencyTunerBackend _internal_latency_tuner_backend() const;
  void _internal_set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value);

  public:
  // optional .rvpb.RvLatencyTunerProfile latency_tuner_profile = 3;
  bool has_latency_tuner_profile() const;
  void clear_latency_tuner_profile() ;
  ::rvpb::RvLatencyTunerProfile latency_tuner_profile() const;
  void set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value);

  private:
  ::rvpb::RvLatencyTunerProfile _internal_latency_tuner_profile() const;
  void _internal_set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value);

  public:
  // optional .rvpb.RvResamplerBackend resampler_backend = 4;
  bool has_resampler_backend() const;
  void clear_resampler_backend() ;
  ::rvpb::RvResamplerBackend resampler_backend() const;
  void set_resampler_backend(::rvpb::RvResamplerBackend value);

  private:
  ::rvpb::RvResamplerBackend _internal_resampler_backend() const;
  void _internal_set_resampler_backend(::rvpb::RvResamplerBackend value);

  public:
  // optional .rvpb.RvResamplerProfile resampler_profile = 5;
  bool has_resampler_profile() const;
  void clear_resampler_profile() ;
  ::rvpb::RvResamplerProfile resampler_profile() const;
  void set_resampler_profile(::rvpb::RvResamplerProfile value);

  private:
  ::rvpb::RvResamplerProfile _internal_resampler_profile() const;
  void _internal_set_resampler_profile(::rvpb::RvResamplerProfile value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvReceiverConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::rvpb::RvPacketEncoding > packet_encodings_;
    ::google::protobuf::Duration* target_latency_;
    ::google::protobuf::Duration* no_playback_timeout_;
    ::google::protobuf::Duration* choppy_playback_timeout_;
    ::google::protobuf::Duration* latency_tolerance_;
    int latency_tuner_backend_;
    int latency_tuner_profile_;
    int resampler_backend_;
    int resampler_profile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvLogEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvLogEntry) */ {
 public:
  inline RvLogEntry() : RvLogEntry(nullptr) {}
  ~RvLogEntry() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvLogEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvLogEntry(const RvLogEntry& from) : RvLogEntry(nullptr, from) {}
  inline RvLogEntry(RvLogEntry&& from) noexcept
      : RvLogEntry(nullptr, std::move(from)) {}
  inline RvLogEntry& operator=(const RvLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvLogEntry& operator=(RvLogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvLogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvLogEntry* internal_default_instance() {
    return reinterpret_cast<const RvLogEntry*>(
        &_RvLogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RvLogEntry& a, RvLogEntry& b) { a.Swap(&b); }
  inline void Swap(RvLogEntry* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvLogEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvLogEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvLogEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvLogEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvLogEntry& from) { RvLogEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvLogEntry* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvLogEntry"; }

 protected:
  explicit RvLogEntry(::google::protobuf::Arena* arena);
  RvLogEntry(::google::protobuf::Arena* arena, const RvLogEntry& from);
  RvLogEntry(::google::protobuf::Arena* arena, RvLogEntry&& from) noexcept
      : RvLogEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Level = RvLogEntry_Level;
  static constexpr Level CRIT = RvLogEntry_Level_CRIT;
  static constexpr Level ERROR = RvLogEntry_Level_ERROR;
  static constexpr Level WARN = RvLogEntry_Level_WARN;
  static constexpr Level INFO = RvLogEntry_Level_INFO;
  static constexpr Level DEBUG = RvLogEntry_Level_DEBUG;
  static constexpr Level TRACE = RvLogEntry_Level_TRACE;
  static inline bool Level_IsValid(int value) {
    return RvLogEntry_Level_IsValid(value);
  }
  static constexpr Level Level_MIN = RvLogEntry_Level_Level_MIN;
  static constexpr Level Level_MAX = RvLogEntry_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE = RvLogEntry_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Level_descriptor() {
    return RvLogEntry_Level_descriptor();
  }
  template <typename T>
  static inline const std::string& Level_Name(T value) {
    return RvLogEntry_Level_Name(value);
  }
  static inline bool Level_Parse(absl::string_view name, Level* value) {
    return RvLogEntry_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 3,
    kTimeFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // string text = 3;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .rvpb.RvLogEntry.Level level = 2;
  void clear_level() ;
  ::rvpb::RvLogEntry_Level level() const;
  void set_level(::rvpb::RvLogEntry_Level value);

  private:
  ::rvpb::RvLogEntry_Level _internal_level() const;
  void _internal_set_level(::rvpb::RvLogEntry_Level value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvLogEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      28, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::Timestamp* time_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvEndpointRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvEndpointRequest) */ {
 public:
  inline RvEndpointRequest() : RvEndpointRequest(nullptr) {}
  ~RvEndpointRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvEndpointRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvEndpointRequest(const RvEndpointRequest& from) : RvEndpointRequest(nullptr, from) {}
  inline RvEndpointRequest(RvEndpointRequest&& from) noexcept
      : RvEndpointRequest(nullptr, std::move(from)) {}
  inline RvEndpointRequest& operator=(const RvEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvEndpointRequest& operator=(RvEndpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvEndpointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const RvEndpointRequest*>(
        &_RvEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RvEndpointRequest& a, RvEndpointRequest& b) { a.Swap(&b); }
  inline void Swap(RvEndpointRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvEndpointRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvEndpointRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvEndpointRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvEndpointRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvEndpointRequest& from) { RvEndpointRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvEndpointRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvEndpointRequest"; }

 protected:
  explicit RvEndpointRequest(::google::protobuf::Arena* arena);
  RvEndpointRequest(::google::protobuf::Arena* arena, const RvEndpointRequest& from);
  RvEndpointRequest(::google::protobuf::Arena* arena, RvEndpointRequest&& from) noexcept
      : RvEndpointRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
    kEndpointFieldNumber = 2,
  };
  // .rvpb.RvDeviceSelector device = 1;
  bool has_device() const;
  void clear_device() ;
  const ::rvpb::RvDeviceSelector& device() const;
  PROTOBUF_NODISCARD ::rvpb::RvDeviceSelector* release_device();
  ::rvpb::RvDeviceSelector* mutable_device();
  void set_allocated_device(::rvpb::RvDeviceSelector* value);
  void unsafe_arena_set_allocated_device(::rvpb::RvDeviceSelector* value);
  ::rvpb::RvDeviceSelector* unsafe_arena_release_device();

  private:
  const ::rvpb::RvDeviceSelector& _internal_device() const;
  ::rvpb::RvDeviceSelector* _internal_mutable_device();

  public:
  // .rvpb.RvEndpointInfo endpoint = 2;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::rvpb::RvEndpointInfo& endpoint() const;
  PROTOBUF_NODISCARD ::rvpb::RvEndpointInfo* release_endpoint();
  ::rvpb::RvEndpointInfo* mutable_endpoint();
  void set_allocated_endpoint(::rvpb::RvEndpointInfo* value);
  void unsafe_arena_set_allocated_endpoint(::rvpb::RvEndpointInfo* value);
  ::rvpb::RvEndpointInfo* unsafe_arena_release_endpoint();

  private:
  const ::rvpb::RvEndpointInfo& _internal_endpoint() const;
  ::rvpb::RvEndpointInfo* _internal_mutable_endpoint();

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvEndpointRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::rvpb::RvDeviceSelector* device_;
    ::rvpb::RvEndpointInfo* endpoint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvDeviceEncoding final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvDeviceEncoding) */ {
 public:
  inline RvDeviceEncoding() : RvDeviceEncoding(nullptr) {}
  ~RvDeviceEncoding() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvDeviceEncoding(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvDeviceEncoding(const RvDeviceEncoding& from) : RvDeviceEncoding(nullptr, from) {}
  inline RvDeviceEncoding(RvDeviceEncoding&& from) noexcept
      : RvDeviceEncoding(nullptr, std::move(from)) {}
  inline RvDeviceEncoding& operator=(const RvDeviceEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvDeviceEncoding& operator=(RvDeviceEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvDeviceEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvDeviceEncoding* internal_default_instance() {
    return reinterpret_cast<const RvDeviceEncoding*>(
        &_RvDeviceEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RvDeviceEncoding& a, RvDeviceEncoding& b) { a.Swap(&b); }
  inline void Swap(RvDeviceEncoding* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvDeviceEncoding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvDeviceEncoding* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvDeviceEncoding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvDeviceEncoding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvDeviceEncoding& from) { RvDeviceEncoding::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvDeviceEncoding* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvDeviceEncoding"; }

 protected:
  explicit RvDeviceEncoding(::google::protobuf::Arena* arena);
  RvDeviceEncoding(::google::protobuf::Arena* arena, const RvDeviceEncoding& from);
  RvDeviceEncoding(::google::protobuf::Arena* arena, RvDeviceEncoding&& from) noexcept
      : RvDeviceEncoding(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBufferLengthFieldNumber = 3,
    kSampleRateFieldNumber = 1,
    kChannelLayoutFieldNumber = 2,
    kTrackCountFieldNumber = 4,
  };
  // optional .google.protobuf.Duration buffer_length = 3;
  bool has_buffer_length() const;
  void clear_buffer_length() ;
  const ::google::protobuf::Duration& buffer_length() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_buffer_length();
  ::google::protobuf::Duration* mutable_buffer_length();
  void set_allocated_buffer_length(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_buffer_length(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_buffer_length();

  private:
  const ::google::protobuf::Duration& _internal_buffer_length() const;
  ::google::protobuf::Duration* _internal_mutable_buffer_length();

  public:
  // optional uint32 sample_rate = 1;
  bool has_sample_rate() const;
  void clear_sample_rate() ;
  ::uint32_t sample_rate() const;
  void set_sample_rate(::uint32_t value);

  private:
  ::uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::uint32_t value);

  public:
  // optional .rvpb.RvChannelLayout channel_layout = 2;
  bool has_channel_layout() const;
  void clear_channel_layout() ;
  ::rvpb::RvChannelLayout channel_layout() const;
  void set_channel_layout(::rvpb::RvChannelLayout value);

  private:
  ::rvpb::RvChannelLayout _internal_channel_layout() const;
  void _internal_set_channel_layout(::rvpb::RvChannelLayout value);

  public:
  // optional uint32 track_count = 4;
  bool has_track_count() const;
  void clear_track_count() ;
  ::uint32_t track_count() const;
  void set_track_count(::uint32_t value);

  private:
  ::uint32_t _internal_track_count() const;
  void _internal_set_track_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:rvpb.RvDeviceEncoding)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Duration* buffer_length_;
    ::uint32_t sample_rate_;
    int channel_layout_;
    ::uint32_t track_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvDeviceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvDeviceInfo) */ {
 public:
  inline RvDeviceInfo() : RvDeviceInfo(nullptr) {}
  ~RvDeviceInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvDeviceInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvDeviceInfo(const RvDeviceInfo& from) : RvDeviceInfo(nullptr, from) {}
  inline RvDeviceInfo(RvDeviceInfo&& from) noexcept
      : RvDeviceInfo(nullptr, std::move(from)) {}
  inline RvDeviceInfo& operator=(const RvDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvDeviceInfo& operator=(RvDeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvDeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  enum NetworkConfigCase {
    kSenderConfig = 7,
    kReceiverConfig = 8,
    NETWORKCONFIG_NOT_SET = 0,
  };
  static inline const RvDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const RvDeviceInfo*>(
        &_RvDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RvDeviceInfo& a, RvDeviceInfo& b) { a.Swap(&b); }
  inline void Swap(RvDeviceInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvDeviceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvDeviceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvDeviceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvDeviceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvDeviceInfo& from) { RvDeviceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvDeviceInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvDeviceInfo"; }

 protected:
  explicit RvDeviceInfo(::google::protobuf::Arena* arena);
  RvDeviceInfo(::google::protobuf::Arena* arena, const RvDeviceInfo& from);
  RvDeviceInfo(::google::protobuf::Arena* arena, RvDeviceInfo&& from) noexcept
      : RvDeviceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocalEndpointsFieldNumber = 9,
    kRemoteEndpointsFieldNumber = 10,
    kUidFieldNumber = 3,
    kNameFieldNumber = 4,
    kDeviceEncodingFieldNumber = 6,
    kTypeFieldNumber = 1,
    kIndexFieldNumber = 2,
    kEnabledFieldNumber = 5,
    kSenderConfigFieldNumber = 7,
    kReceiverConfigFieldNumber = 8,
  };
  // repeated .rvpb.RvEndpointInfo local_endpoints = 9;
  int local_endpoints_size() const;
  private:
  int _internal_local_endpoints_size() const;

  public:
  void clear_local_endpoints() ;
  ::rvpb::RvEndpointInfo* mutable_local_endpoints(int index);
  ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>* mutable_local_endpoints();

  private:
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>& _internal_local_endpoints() const;
  ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>* _internal_mutable_local_endpoints();
  public:
  const ::rvpb::RvEndpointInfo& local_endpoints(int index) const;
  ::rvpb::RvEndpointInfo* add_local_endpoints();
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>& local_endpoints() const;
  // repeated .rvpb.RvEndpointInfo remote_endpoints = 10;
  int remote_endpoints_size() const;
  private:
  int _internal_remote_endpoints_size() const;

  public:
  void clear_remote_endpoints() ;
  ::rvpb::RvEndpointInfo* mutable_remote_endpoints(int index);
  ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>* mutable_remote_endpoints();

  private:
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>& _internal_remote_endpoints() const;
  ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>* _internal_mutable_remote_endpoints();
  public:
  const ::rvpb::RvEndpointInfo& remote_endpoints(int index) const;
  ::rvpb::RvEndpointInfo* add_remote_endpoints();
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>& remote_endpoints() const;
  // optional string uid = 3;
  bool has_uid() const;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // optional string name = 4;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .rvpb.RvDeviceEncoding device_encoding = 6;
  bool has_device_encoding() const;
  void clear_device_encoding() ;
  const ::rvpb::RvDeviceEncoding& device_encoding() const;
  PROTOBUF_NODISCARD ::rvpb::RvDeviceEncoding* release_device_encoding();
  ::rvpb::RvDeviceEncoding* mutable_device_encoding();
  void set_allocated_device_encoding(::rvpb::RvDeviceEncoding* value);
  void unsafe_arena_set_allocated_device_encoding(::rvpb::RvDeviceEncoding* value);
  ::rvpb::RvDeviceEncoding* unsafe_arena_release_device_encoding();

  private:
  const ::rvpb::RvDeviceEncoding& _internal_device_encoding() const;
  ::rvpb::RvDeviceEncoding* _internal_mutable_device_encoding();

  public:
  // .rvpb.RvDeviceType type = 1;
  void clear_type() ;
  ::rvpb::RvDeviceType type() const;
  void set_type(::rvpb::RvDeviceType value);

  private:
  ::rvpb::RvDeviceType _internal_type() const;
  void _internal_set_type(::rvpb::RvDeviceType value);

  public:
  // optional uint32 index = 2;
  bool has_index() const;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // optional bool enabled = 5;
  bool has_enabled() const;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // .rvpb.RvSenderConfig sender_config = 7;
  bool has_sender_config() const;
  private:
  bool _internal_has_sender_config() const;

  public:
  void clear_sender_config() ;
  const ::rvpb::RvSenderConfig& sender_config() const;
  PROTOBUF_NODISCARD ::rvpb::RvSenderConfig* release_sender_config();
  ::rvpb::RvSenderConfig* mutable_sender_config();
  void set_allocated_sender_config(::rvpb::RvSenderConfig* value);
  void unsafe_arena_set_allocated_sender_config(::rvpb::RvSenderConfig* value);
  ::rvpb::RvSenderConfig* unsafe_arena_release_sender_config();

  private:
  const ::rvpb::RvSenderConfig& _internal_sender_config() const;
  ::rvpb::RvSenderConfig* _internal_mutable_sender_config();

  public:
  // .rvpb.RvReceiverConfig receiver_config = 8;
  bool has_receiver_config() const;
  private:
  bool _internal_has_receiver_config() const;

  public:
  void clear_receiver_config() ;
  const ::rvpb::RvReceiverConfig& receiver_config() const;
  PROTOBUF_NODISCARD ::rvpb::RvReceiverConfig* release_receiver_config();
  ::rvpb::RvReceiverConfig* mutable_receiver_config();
  void set_allocated_receiver_config(::rvpb::RvReceiverConfig* value);
  void unsafe_arena_set_allocated_receiver_config(::rvpb::RvReceiverConfig* value);
  ::rvpb::RvReceiverConfig* unsafe_arena_release_receiver_config();

  private:
  const ::rvpb::RvReceiverConfig& _internal_receiver_config() const;
  ::rvpb::RvReceiverConfig* _internal_mutable_receiver_config();

  public:
  void clear_NetworkConfig();
  NetworkConfigCase NetworkConfig_case() const;
  // @@protoc_insertion_point(class_scope:rvpb.RvDeviceInfo)
 private:
  class _Internal;
  void set_has_sender_config();
  void set_has_receiver_config();
  inline bool has_NetworkConfig() const;
  inline void clear_has_NetworkConfig();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 5,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::rvpb::RvEndpointInfo > local_endpoints_;
    ::google::protobuf::RepeatedPtrField< ::rvpb::RvEndpointInfo > remote_endpoints_;
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::rvpb::RvDeviceEncoding* device_encoding_;
    int type_;
    ::uint32_t index_;
    bool enabled_;
    union NetworkConfigUnion {
      constexpr NetworkConfigUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::rvpb::RvSenderConfig* sender_config_;
      ::rvpb::RvReceiverConfig* receiver_config_;
    } NetworkConfig_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};
// -------------------------------------------------------------------

class RvDeviceList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:rvpb.RvDeviceList) */ {
 public:
  inline RvDeviceList() : RvDeviceList(nullptr) {}
  ~RvDeviceList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RvDeviceList(
      ::google::protobuf::internal::ConstantInitialized);

  inline RvDeviceList(const RvDeviceList& from) : RvDeviceList(nullptr, from) {}
  inline RvDeviceList(RvDeviceList&& from) noexcept
      : RvDeviceList(nullptr, std::move(from)) {}
  inline RvDeviceList& operator=(const RvDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RvDeviceList& operator=(RvDeviceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RvDeviceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RvDeviceList* internal_default_instance() {
    return reinterpret_cast<const RvDeviceList*>(
        &_RvDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RvDeviceList& a, RvDeviceList& b) { a.Swap(&b); }
  inline void Swap(RvDeviceList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RvDeviceList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RvDeviceList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RvDeviceList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RvDeviceList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RvDeviceList& from) { RvDeviceList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RvDeviceList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "rvpb.RvDeviceList"; }

 protected:
  explicit RvDeviceList(::google::protobuf::Arena* arena);
  RvDeviceList(::google::protobuf::Arena* arena, const RvDeviceList& from);
  RvDeviceList(::google::protobuf::Arena* arena, RvDeviceList&& from) noexcept
      : RvDeviceList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .rvpb.RvDeviceInfo devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;

  public:
  void clear_devices() ;
  ::rvpb::RvDeviceInfo* mutable_devices(int index);
  ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>* mutable_devices();

  private:
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>& _internal_devices() const;
  ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>* _internal_mutable_devices();
  public:
  const ::rvpb::RvDeviceInfo& devices(int index) const;
  ::rvpb::RvDeviceInfo* add_devices();
  const ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>& devices() const;
  // @@protoc_insertion_point(class_scope:rvpb.RvDeviceList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::rvpb::RvDeviceInfo > devices_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_driver_5fprotocol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RvNone

// -------------------------------------------------------------------

// RvDriverInfo

// string version = 1;
inline void RvDriverInfo::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& RvDriverInfo::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDriverInfo.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvDriverInfo::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvDriverInfo.version)
}
inline std::string* RvDriverInfo::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDriverInfo.version)
  return _s;
}
inline const std::string& RvDriverInfo::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void RvDriverInfo::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.Set(value, GetArena());
}
inline std::string* RvDriverInfo::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* RvDriverInfo::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDriverInfo.version)
  return _impl_.version_.Release();
}
inline void RvDriverInfo::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDriverInfo.version)
}

// string commit = 2;
inline void RvDriverInfo::clear_commit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.ClearToEmpty();
}
inline const std::string& RvDriverInfo::commit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDriverInfo.commit)
  return _internal_commit();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvDriverInfo::set_commit(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvDriverInfo.commit)
}
inline std::string* RvDriverInfo::mutable_commit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDriverInfo.commit)
  return _s;
}
inline const std::string& RvDriverInfo::_internal_commit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commit_.Get();
}
inline void RvDriverInfo::_internal_set_commit(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.Set(value, GetArena());
}
inline std::string* RvDriverInfo::_internal_mutable_commit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.commit_.Mutable( GetArena());
}
inline std::string* RvDriverInfo::release_commit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDriverInfo.commit)
  return _impl_.commit_.Release();
}
inline void RvDriverInfo::set_allocated_commit(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commit_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commit_.IsDefault()) {
          _impl_.commit_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDriverInfo.commit)
}

// -------------------------------------------------------------------

// RvLogEntry

// .google.protobuf.Timestamp time = 1;
inline bool RvLogEntry::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RvLogEntry::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RvLogEntry::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvLogEntry.time)
  return _internal_time();
}
inline void RvLogEntry::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvLogEntry.time)
}
inline ::google::protobuf::Timestamp* RvLogEntry::release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* RvLogEntry::unsafe_arena_release_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvLogEntry.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RvLogEntry::_internal_mutable_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* RvLogEntry::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:rvpb.RvLogEntry.time)
  return _msg;
}
inline void RvLogEntry::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvLogEntry.time)
}

// .rvpb.RvLogEntry.Level level = 2;
inline void RvLogEntry::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::rvpb::RvLogEntry_Level RvLogEntry::level() const {
  // @@protoc_insertion_point(field_get:rvpb.RvLogEntry.level)
  return _internal_level();
}
inline void RvLogEntry::set_level(::rvpb::RvLogEntry_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:rvpb.RvLogEntry.level)
}
inline ::rvpb::RvLogEntry_Level RvLogEntry::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvLogEntry_Level>(_impl_.level_);
}
inline void RvLogEntry::_internal_set_level(::rvpb::RvLogEntry_Level value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// string text = 3;
inline void RvLogEntry::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& RvLogEntry::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvLogEntry.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvLogEntry::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvLogEntry.text)
}
inline std::string* RvLogEntry::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:rvpb.RvLogEntry.text)
  return _s;
}
inline const std::string& RvLogEntry::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void RvLogEntry::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* RvLogEntry::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* RvLogEntry::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvLogEntry.text)
  return _impl_.text_.Release();
}
inline void RvLogEntry::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvLogEntry.text)
}

// -------------------------------------------------------------------

// RvDeviceSelector

// uint32 index = 1;
inline bool RvDeviceSelector::has_index() const {
  return Selector_case() == kIndex;
}
inline void RvDeviceSelector::set_has_index() {
  _impl_._oneof_case_[0] = kIndex;
}
inline void RvDeviceSelector::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() == kIndex) {
    _impl_.Selector_.index_ = 0u;
    clear_has_Selector();
  }
}
inline ::uint32_t RvDeviceSelector::index() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceSelector.index)
  return _internal_index();
}
inline void RvDeviceSelector::set_index(::uint32_t value) {
  if (Selector_case() != kIndex) {
    clear_Selector();
    set_has_index();
  }
  _impl_.Selector_.index_ = value;
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceSelector.index)
}
inline ::uint32_t RvDeviceSelector::_internal_index() const {
  if (Selector_case() == kIndex) {
    return _impl_.Selector_.index_;
  }
  return 0u;
}

// string uid = 2;
inline bool RvDeviceSelector::has_uid() const {
  return Selector_case() == kUid;
}
inline void RvDeviceSelector::set_has_uid() {
  _impl_._oneof_case_[0] = kUid;
}
inline void RvDeviceSelector::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() == kUid) {
    _impl_.Selector_.uid_.Destroy();
    clear_has_Selector();
  }
}
inline const std::string& RvDeviceSelector::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceSelector.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvDeviceSelector::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    clear_Selector();

    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  _impl_.Selector_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceSelector.uid)
}
inline std::string* RvDeviceSelector::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceSelector.uid)
  return _s;
}
inline const std::string& RvDeviceSelector::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.Selector_.uid_.Get();
}
inline void RvDeviceSelector::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    clear_Selector();

    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  _impl_.Selector_.uid_.Set(value, GetArena());
}
inline std::string* RvDeviceSelector::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (Selector_case() != kUid) {
    clear_Selector();

    set_has_uid();
    _impl_.Selector_.uid_.InitDefault();
  }
  return _impl_.Selector_.uid_.Mutable( GetArena());
}
inline std::string* RvDeviceSelector::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceSelector.uid)
  if (Selector_case() != kUid) {
    return nullptr;
  }
  clear_has_Selector();
  return _impl_.Selector_.uid_.Release();
}
inline void RvDeviceSelector::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_Selector()) {
    clear_Selector();
  }
  if (value != nullptr) {
    set_has_uid();
    _impl_.Selector_.uid_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDeviceSelector.uid)
}

inline bool RvDeviceSelector::has_Selector() const {
  return Selector_case() != SELECTOR_NOT_SET;
}
inline void RvDeviceSelector::clear_has_Selector() {
  _impl_._oneof_case_[0] = SELECTOR_NOT_SET;
}
inline RvDeviceSelector::SelectorCase RvDeviceSelector::Selector_case() const {
  return RvDeviceSelector::SelectorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RvDeviceInfo

// .rvpb.RvDeviceType type = 1;
inline void RvDeviceInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::rvpb::RvDeviceType RvDeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.type)
  return _internal_type();
}
inline void RvDeviceInfo::set_type(::rvpb::RvDeviceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceInfo.type)
}
inline ::rvpb::RvDeviceType RvDeviceInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvDeviceType>(_impl_.type_);
}
inline void RvDeviceInfo::_internal_set_type(::rvpb::RvDeviceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional uint32 index = 2;
inline bool RvDeviceInfo::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RvDeviceInfo::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RvDeviceInfo::index() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.index)
  return _internal_index();
}
inline void RvDeviceInfo::set_index(::uint32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceInfo.index)
}
inline ::uint32_t RvDeviceInfo::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void RvDeviceInfo::_internal_set_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = value;
}

// optional string uid = 3;
inline bool RvDeviceInfo::has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RvDeviceInfo::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RvDeviceInfo::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvDeviceInfo::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceInfo.uid)
}
inline std::string* RvDeviceInfo::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.uid)
  return _s;
}
inline const std::string& RvDeviceInfo::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void RvDeviceInfo::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* RvDeviceInfo::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* RvDeviceInfo::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceInfo.uid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RvDeviceInfo::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDeviceInfo.uid)
}

// optional string name = 4;
inline bool RvDeviceInfo::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RvDeviceInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RvDeviceInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvDeviceInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceInfo.name)
}
inline std::string* RvDeviceInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.name)
  return _s;
}
inline const std::string& RvDeviceInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RvDeviceInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RvDeviceInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RvDeviceInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RvDeviceInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDeviceInfo.name)
}

// optional bool enabled = 5;
inline bool RvDeviceInfo::has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RvDeviceInfo::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RvDeviceInfo::enabled() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.enabled)
  return _internal_enabled();
}
inline void RvDeviceInfo::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceInfo.enabled)
}
inline bool RvDeviceInfo::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void RvDeviceInfo::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = value;
}

// .rvpb.RvDeviceEncoding device_encoding = 6;
inline bool RvDeviceInfo::has_device_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_encoding_ != nullptr);
  return value;
}
inline void RvDeviceInfo::clear_device_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_encoding_ != nullptr) _impl_.device_encoding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::rvpb::RvDeviceEncoding& RvDeviceInfo::_internal_device_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rvpb::RvDeviceEncoding* p = _impl_.device_encoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::rvpb::RvDeviceEncoding&>(::rvpb::_RvDeviceEncoding_default_instance_);
}
inline const ::rvpb::RvDeviceEncoding& RvDeviceInfo::device_encoding() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.device_encoding)
  return _internal_device_encoding();
}
inline void RvDeviceInfo::unsafe_arena_set_allocated_device_encoding(::rvpb::RvDeviceEncoding* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_encoding_);
  }
  _impl_.device_encoding_ = reinterpret_cast<::rvpb::RvDeviceEncoding*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvDeviceInfo.device_encoding)
}
inline ::rvpb::RvDeviceEncoding* RvDeviceInfo::release_device_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::rvpb::RvDeviceEncoding* released = _impl_.device_encoding_;
  _impl_.device_encoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rvpb::RvDeviceEncoding* RvDeviceInfo::unsafe_arena_release_device_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceInfo.device_encoding)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::rvpb::RvDeviceEncoding* temp = _impl_.device_encoding_;
  _impl_.device_encoding_ = nullptr;
  return temp;
}
inline ::rvpb::RvDeviceEncoding* RvDeviceInfo::_internal_mutable_device_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_encoding_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rvpb::RvDeviceEncoding>(GetArena());
    _impl_.device_encoding_ = reinterpret_cast<::rvpb::RvDeviceEncoding*>(p);
  }
  return _impl_.device_encoding_;
}
inline ::rvpb::RvDeviceEncoding* RvDeviceInfo::mutable_device_encoding() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::rvpb::RvDeviceEncoding* _msg = _internal_mutable_device_encoding();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.device_encoding)
  return _msg;
}
inline void RvDeviceInfo::set_allocated_device_encoding(::rvpb::RvDeviceEncoding* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.device_encoding_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.device_encoding_ = reinterpret_cast<::rvpb::RvDeviceEncoding*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDeviceInfo.device_encoding)
}

// .rvpb.RvSenderConfig sender_config = 7;
inline bool RvDeviceInfo::has_sender_config() const {
  return NetworkConfig_case() == kSenderConfig;
}
inline bool RvDeviceInfo::_internal_has_sender_config() const {
  return NetworkConfig_case() == kSenderConfig;
}
inline void RvDeviceInfo::set_has_sender_config() {
  _impl_._oneof_case_[0] = kSenderConfig;
}
inline void RvDeviceInfo::clear_sender_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (NetworkConfig_case() == kSenderConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.NetworkConfig_.sender_config_;
    }
    clear_has_NetworkConfig();
  }
}
inline ::rvpb::RvSenderConfig* RvDeviceInfo::release_sender_config() {
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceInfo.sender_config)
  if (NetworkConfig_case() == kSenderConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.sender_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.NetworkConfig_.sender_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rvpb::RvSenderConfig& RvDeviceInfo::_internal_sender_config() const {
  return NetworkConfig_case() == kSenderConfig ? *_impl_.NetworkConfig_.sender_config_ : reinterpret_cast<::rvpb::RvSenderConfig&>(::rvpb::_RvSenderConfig_default_instance_);
}
inline const ::rvpb::RvSenderConfig& RvDeviceInfo::sender_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.sender_config)
  return _internal_sender_config();
}
inline ::rvpb::RvSenderConfig* RvDeviceInfo::unsafe_arena_release_sender_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rvpb.RvDeviceInfo.sender_config)
  if (NetworkConfig_case() == kSenderConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.sender_config_;
    _impl_.NetworkConfig_.sender_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RvDeviceInfo::unsafe_arena_set_allocated_sender_config(::rvpb::RvSenderConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_NetworkConfig();
  if (value) {
    set_has_sender_config();
    _impl_.NetworkConfig_.sender_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvDeviceInfo.sender_config)
}
inline ::rvpb::RvSenderConfig* RvDeviceInfo::_internal_mutable_sender_config() {
  if (NetworkConfig_case() != kSenderConfig) {
    clear_NetworkConfig();
    set_has_sender_config();
    _impl_.NetworkConfig_.sender_config_ =
        ::google::protobuf::Message::DefaultConstruct<::rvpb::RvSenderConfig>(GetArena());
  }
  return _impl_.NetworkConfig_.sender_config_;
}
inline ::rvpb::RvSenderConfig* RvDeviceInfo::mutable_sender_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rvpb::RvSenderConfig* _msg = _internal_mutable_sender_config();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.sender_config)
  return _msg;
}

// .rvpb.RvReceiverConfig receiver_config = 8;
inline bool RvDeviceInfo::has_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig;
}
inline bool RvDeviceInfo::_internal_has_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig;
}
inline void RvDeviceInfo::set_has_receiver_config() {
  _impl_._oneof_case_[0] = kReceiverConfig;
}
inline void RvDeviceInfo::clear_receiver_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (NetworkConfig_case() == kReceiverConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.NetworkConfig_.receiver_config_;
    }
    clear_has_NetworkConfig();
  }
}
inline ::rvpb::RvReceiverConfig* RvDeviceInfo::release_receiver_config() {
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceInfo.receiver_config)
  if (NetworkConfig_case() == kReceiverConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.receiver_config_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.NetworkConfig_.receiver_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rvpb::RvReceiverConfig& RvDeviceInfo::_internal_receiver_config() const {
  return NetworkConfig_case() == kReceiverConfig ? *_impl_.NetworkConfig_.receiver_config_ : reinterpret_cast<::rvpb::RvReceiverConfig&>(::rvpb::_RvReceiverConfig_default_instance_);
}
inline const ::rvpb::RvReceiverConfig& RvDeviceInfo::receiver_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.receiver_config)
  return _internal_receiver_config();
}
inline ::rvpb::RvReceiverConfig* RvDeviceInfo::unsafe_arena_release_receiver_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rvpb.RvDeviceInfo.receiver_config)
  if (NetworkConfig_case() == kReceiverConfig) {
    clear_has_NetworkConfig();
    auto* temp = _impl_.NetworkConfig_.receiver_config_;
    _impl_.NetworkConfig_.receiver_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RvDeviceInfo::unsafe_arena_set_allocated_receiver_config(::rvpb::RvReceiverConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_NetworkConfig();
  if (value) {
    set_has_receiver_config();
    _impl_.NetworkConfig_.receiver_config_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvDeviceInfo.receiver_config)
}
inline ::rvpb::RvReceiverConfig* RvDeviceInfo::_internal_mutable_receiver_config() {
  if (NetworkConfig_case() != kReceiverConfig) {
    clear_NetworkConfig();
    set_has_receiver_config();
    _impl_.NetworkConfig_.receiver_config_ =
        ::google::protobuf::Message::DefaultConstruct<::rvpb::RvReceiverConfig>(GetArena());
  }
  return _impl_.NetworkConfig_.receiver_config_;
}
inline ::rvpb::RvReceiverConfig* RvDeviceInfo::mutable_receiver_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::rvpb::RvReceiverConfig* _msg = _internal_mutable_receiver_config();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.receiver_config)
  return _msg;
}

// repeated .rvpb.RvEndpointInfo local_endpoints = 9;
inline int RvDeviceInfo::_internal_local_endpoints_size() const {
  return _internal_local_endpoints().size();
}
inline int RvDeviceInfo::local_endpoints_size() const {
  return _internal_local_endpoints_size();
}
inline void RvDeviceInfo::clear_local_endpoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_endpoints_.Clear();
}
inline ::rvpb::RvEndpointInfo* RvDeviceInfo::mutable_local_endpoints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.local_endpoints)
  return _internal_mutable_local_endpoints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>* RvDeviceInfo::mutable_local_endpoints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rvpb.RvDeviceInfo.local_endpoints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_local_endpoints();
}
inline const ::rvpb::RvEndpointInfo& RvDeviceInfo::local_endpoints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.local_endpoints)
  return _internal_local_endpoints().Get(index);
}
inline ::rvpb::RvEndpointInfo* RvDeviceInfo::add_local_endpoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rvpb::RvEndpointInfo* _add = _internal_mutable_local_endpoints()->Add();
  // @@protoc_insertion_point(field_add:rvpb.RvDeviceInfo.local_endpoints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>& RvDeviceInfo::local_endpoints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rvpb.RvDeviceInfo.local_endpoints)
  return _internal_local_endpoints();
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>&
RvDeviceInfo::_internal_local_endpoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_endpoints_;
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>*
RvDeviceInfo::_internal_mutable_local_endpoints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.local_endpoints_;
}

// repeated .rvpb.RvEndpointInfo remote_endpoints = 10;
inline int RvDeviceInfo::_internal_remote_endpoints_size() const {
  return _internal_remote_endpoints().size();
}
inline int RvDeviceInfo::remote_endpoints_size() const {
  return _internal_remote_endpoints_size();
}
inline void RvDeviceInfo::clear_remote_endpoints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_endpoints_.Clear();
}
inline ::rvpb::RvEndpointInfo* RvDeviceInfo::mutable_remote_endpoints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceInfo.remote_endpoints)
  return _internal_mutable_remote_endpoints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>* RvDeviceInfo::mutable_remote_endpoints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rvpb.RvDeviceInfo.remote_endpoints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_remote_endpoints();
}
inline const ::rvpb::RvEndpointInfo& RvDeviceInfo::remote_endpoints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceInfo.remote_endpoints)
  return _internal_remote_endpoints().Get(index);
}
inline ::rvpb::RvEndpointInfo* RvDeviceInfo::add_remote_endpoints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rvpb::RvEndpointInfo* _add = _internal_mutable_remote_endpoints()->Add();
  // @@protoc_insertion_point(field_add:rvpb.RvDeviceInfo.remote_endpoints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>& RvDeviceInfo::remote_endpoints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rvpb.RvDeviceInfo.remote_endpoints)
  return _internal_remote_endpoints();
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>&
RvDeviceInfo::_internal_remote_endpoints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_endpoints_;
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvEndpointInfo>*
RvDeviceInfo::_internal_mutable_remote_endpoints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.remote_endpoints_;
}

inline bool RvDeviceInfo::has_NetworkConfig() const {
  return NetworkConfig_case() != NETWORKCONFIG_NOT_SET;
}
inline void RvDeviceInfo::clear_has_NetworkConfig() {
  _impl_._oneof_case_[0] = NETWORKCONFIG_NOT_SET;
}
inline RvDeviceInfo::NetworkConfigCase RvDeviceInfo::NetworkConfig_case() const {
  return RvDeviceInfo::NetworkConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RvDeviceList

// repeated .rvpb.RvDeviceInfo devices = 1;
inline int RvDeviceList::_internal_devices_size() const {
  return _internal_devices().size();
}
inline int RvDeviceList::devices_size() const {
  return _internal_devices_size();
}
inline void RvDeviceList::clear_devices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.devices_.Clear();
}
inline ::rvpb::RvDeviceInfo* RvDeviceList::mutable_devices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceList.devices)
  return _internal_mutable_devices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>* RvDeviceList::mutable_devices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rvpb.RvDeviceList.devices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_devices();
}
inline const ::rvpb::RvDeviceInfo& RvDeviceList::devices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceList.devices)
  return _internal_devices().Get(index);
}
inline ::rvpb::RvDeviceInfo* RvDeviceList::add_devices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rvpb::RvDeviceInfo* _add = _internal_mutable_devices()->Add();
  // @@protoc_insertion_point(field_add:rvpb.RvDeviceList.devices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>& RvDeviceList::devices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rvpb.RvDeviceList.devices)
  return _internal_devices();
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>&
RvDeviceList::_internal_devices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.devices_;
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvDeviceInfo>*
RvDeviceList::_internal_mutable_devices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.devices_;
}

// -------------------------------------------------------------------

// RvToggleRequest

// .rvpb.RvDeviceSelector device = 1;
inline bool RvToggleRequest::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void RvToggleRequest::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rvpb::RvDeviceSelector& RvToggleRequest::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rvpb::RvDeviceSelector* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::rvpb::RvDeviceSelector&>(::rvpb::_RvDeviceSelector_default_instance_);
}
inline const ::rvpb::RvDeviceSelector& RvToggleRequest::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvToggleRequest.device)
  return _internal_device();
}
inline void RvToggleRequest::unsafe_arena_set_allocated_device(::rvpb::RvDeviceSelector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::rvpb::RvDeviceSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvToggleRequest.device)
}
inline ::rvpb::RvDeviceSelector* RvToggleRequest::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rvpb::RvDeviceSelector* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rvpb::RvDeviceSelector* RvToggleRequest::unsafe_arena_release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvToggleRequest.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rvpb::RvDeviceSelector* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::rvpb::RvDeviceSelector* RvToggleRequest::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rvpb::RvDeviceSelector>(GetArena());
    _impl_.device_ = reinterpret_cast<::rvpb::RvDeviceSelector*>(p);
  }
  return _impl_.device_;
}
inline ::rvpb::RvDeviceSelector* RvToggleRequest::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::rvpb::RvDeviceSelector* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:rvpb.RvToggleRequest.device)
  return _msg;
}
inline void RvToggleRequest::set_allocated_device(::rvpb::RvDeviceSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::rvpb::RvDeviceSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvToggleRequest.device)
}

// bool enabled = 2;
inline void RvToggleRequest::clear_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = false;
}
inline bool RvToggleRequest::enabled() const {
  // @@protoc_insertion_point(field_get:rvpb.RvToggleRequest.enabled)
  return _internal_enabled();
}
inline void RvToggleRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:rvpb.RvToggleRequest.enabled)
}
inline bool RvToggleRequest::_internal_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enabled_;
}
inline void RvToggleRequest::_internal_set_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enabled_ = value;
}

// -------------------------------------------------------------------

// RvEndpointRequest

// .rvpb.RvDeviceSelector device = 1;
inline bool RvEndpointRequest::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline void RvEndpointRequest::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_ != nullptr) _impl_.device_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rvpb::RvDeviceSelector& RvEndpointRequest::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rvpb::RvDeviceSelector* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::rvpb::RvDeviceSelector&>(::rvpb::_RvDeviceSelector_default_instance_);
}
inline const ::rvpb::RvDeviceSelector& RvEndpointRequest::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvEndpointRequest.device)
  return _internal_device();
}
inline void RvEndpointRequest::unsafe_arena_set_allocated_device(::rvpb::RvDeviceSelector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::rvpb::RvDeviceSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvEndpointRequest.device)
}
inline ::rvpb::RvDeviceSelector* RvEndpointRequest::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rvpb::RvDeviceSelector* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rvpb::RvDeviceSelector* RvEndpointRequest::unsafe_arena_release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvEndpointRequest.device)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rvpb::RvDeviceSelector* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::rvpb::RvDeviceSelector* RvEndpointRequest::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.device_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rvpb::RvDeviceSelector>(GetArena());
    _impl_.device_ = reinterpret_cast<::rvpb::RvDeviceSelector*>(p);
  }
  return _impl_.device_;
}
inline ::rvpb::RvDeviceSelector* RvEndpointRequest::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::rvpb::RvDeviceSelector* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:rvpb.RvEndpointRequest.device)
  return _msg;
}
inline void RvEndpointRequest::set_allocated_device(::rvpb::RvDeviceSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.device_ = reinterpret_cast<::rvpb::RvDeviceSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvEndpointRequest.device)
}

// .rvpb.RvEndpointInfo endpoint = 2;
inline bool RvEndpointRequest::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline void RvEndpointRequest::clear_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endpoint_ != nullptr) _impl_.endpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::rvpb::RvEndpointInfo& RvEndpointRequest::_internal_endpoint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rvpb::RvEndpointInfo* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::rvpb::RvEndpointInfo&>(::rvpb::_RvEndpointInfo_default_instance_);
}
inline const ::rvpb::RvEndpointInfo& RvEndpointRequest::endpoint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvEndpointRequest.endpoint)
  return _internal_endpoint();
}
inline void RvEndpointRequest::unsafe_arena_set_allocated_endpoint(::rvpb::RvEndpointInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = reinterpret_cast<::rvpb::RvEndpointInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvEndpointRequest.endpoint)
}
inline ::rvpb::RvEndpointInfo* RvEndpointRequest::release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rvpb::RvEndpointInfo* released = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rvpb::RvEndpointInfo* RvEndpointRequest::unsafe_arena_release_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvEndpointRequest.endpoint)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::rvpb::RvEndpointInfo* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::rvpb::RvEndpointInfo* RvEndpointRequest::_internal_mutable_endpoint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endpoint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rvpb::RvEndpointInfo>(GetArena());
    _impl_.endpoint_ = reinterpret_cast<::rvpb::RvEndpointInfo*>(p);
  }
  return _impl_.endpoint_;
}
inline ::rvpb::RvEndpointInfo* RvEndpointRequest::mutable_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::rvpb::RvEndpointInfo* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:rvpb.RvEndpointRequest.endpoint)
  return _msg;
}
inline void RvEndpointRequest::set_allocated_endpoint(::rvpb::RvEndpointInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.endpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.endpoint_ = reinterpret_cast<::rvpb::RvEndpointInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvEndpointRequest.endpoint)
}

// -------------------------------------------------------------------

// RvEndpointInfo

// optional uint32 slot = 1;
inline bool RvEndpointInfo::has_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RvEndpointInfo::clear_slot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slot_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t RvEndpointInfo::slot() const {
  // @@protoc_insertion_point(field_get:rvpb.RvEndpointInfo.slot)
  return _internal_slot();
}
inline void RvEndpointInfo::set_slot(::uint32_t value) {
  _internal_set_slot(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:rvpb.RvEndpointInfo.slot)
}
inline ::uint32_t RvEndpointInfo::_internal_slot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slot_;
}
inline void RvEndpointInfo::_internal_set_slot(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slot_ = value;
}

// .rvpb.RvInterface interface = 2;
inline void RvEndpointInfo::clear_interface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_ = 0;
}
inline ::rvpb::RvInterface RvEndpointInfo::interface() const {
  // @@protoc_insertion_point(field_get:rvpb.RvEndpointInfo.interface)
  return _internal_interface();
}
inline void RvEndpointInfo::set_interface(::rvpb::RvInterface value) {
  _internal_set_interface(value);
  // @@protoc_insertion_point(field_set:rvpb.RvEndpointInfo.interface)
}
inline ::rvpb::RvInterface RvEndpointInfo::_internal_interface() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvInterface>(_impl_.interface_);
}
inline void RvEndpointInfo::_internal_set_interface(::rvpb::RvInterface value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interface_ = value;
}

// string uri = 3;
inline void RvEndpointInfo::clear_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& RvEndpointInfo::uri() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvEndpointInfo.uri)
  return _internal_uri();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RvEndpointInfo::set_uri(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:rvpb.RvEndpointInfo.uri)
}
inline std::string* RvEndpointInfo::mutable_uri() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:rvpb.RvEndpointInfo.uri)
  return _s;
}
inline const std::string& RvEndpointInfo::_internal_uri() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uri_.Get();
}
inline void RvEndpointInfo::_internal_set_uri(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.Set(value, GetArena());
}
inline std::string* RvEndpointInfo::_internal_mutable_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.uri_.Mutable( GetArena());
}
inline std::string* RvEndpointInfo::release_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvEndpointInfo.uri)
  return _impl_.uri_.Release();
}
inline void RvEndpointInfo::set_allocated_uri(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uri_.IsDefault()) {
          _impl_.uri_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvEndpointInfo.uri)
}

// -------------------------------------------------------------------

// RvSenderConfig

// optional .rvpb.RvPacketEncoding packet_encoding = 1;
inline bool RvSenderConfig::has_packet_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_encoding_ != nullptr);
  return value;
}
inline void RvSenderConfig::clear_packet_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.packet_encoding_ != nullptr) _impl_.packet_encoding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::rvpb::RvPacketEncoding& RvSenderConfig::_internal_packet_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::rvpb::RvPacketEncoding* p = _impl_.packet_encoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::rvpb::RvPacketEncoding&>(::rvpb::_RvPacketEncoding_default_instance_);
}
inline const ::rvpb::RvPacketEncoding& RvSenderConfig::packet_encoding() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.packet_encoding)
  return _internal_packet_encoding();
}
inline void RvSenderConfig::unsafe_arena_set_allocated_packet_encoding(::rvpb::RvPacketEncoding* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_encoding_);
  }
  _impl_.packet_encoding_ = reinterpret_cast<::rvpb::RvPacketEncoding*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvSenderConfig.packet_encoding)
}
inline ::rvpb::RvPacketEncoding* RvSenderConfig::release_packet_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rvpb::RvPacketEncoding* released = _impl_.packet_encoding_;
  _impl_.packet_encoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::rvpb::RvPacketEncoding* RvSenderConfig::unsafe_arena_release_packet_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvSenderConfig.packet_encoding)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::rvpb::RvPacketEncoding* temp = _impl_.packet_encoding_;
  _impl_.packet_encoding_ = nullptr;
  return temp;
}
inline ::rvpb::RvPacketEncoding* RvSenderConfig::_internal_mutable_packet_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.packet_encoding_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::rvpb::RvPacketEncoding>(GetArena());
    _impl_.packet_encoding_ = reinterpret_cast<::rvpb::RvPacketEncoding*>(p);
  }
  return _impl_.packet_encoding_;
}
inline ::rvpb::RvPacketEncoding* RvSenderConfig::mutable_packet_encoding() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::rvpb::RvPacketEncoding* _msg = _internal_mutable_packet_encoding();
  // @@protoc_insertion_point(field_mutable:rvpb.RvSenderConfig.packet_encoding)
  return _msg;
}
inline void RvSenderConfig::set_allocated_packet_encoding(::rvpb::RvPacketEncoding* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.packet_encoding_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.packet_encoding_ = reinterpret_cast<::rvpb::RvPacketEncoding*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvSenderConfig.packet_encoding)
}

// optional .google.protobuf.Duration packet_length = 2;
inline bool RvSenderConfig::has_packet_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_length_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvSenderConfig::_internal_packet_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.packet_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvSenderConfig::packet_length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.packet_length)
  return _internal_packet_length();
}
inline void RvSenderConfig::unsafe_arena_set_allocated_packet_length(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_length_);
  }
  _impl_.packet_length_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvSenderConfig.packet_length)
}
inline ::google::protobuf::Duration* RvSenderConfig::release_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvSenderConfig::unsafe_arena_release_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvSenderConfig.packet_length)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.packet_length_;
  _impl_.packet_length_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvSenderConfig::_internal_mutable_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.packet_length_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.packet_length_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.packet_length_;
}
inline ::google::protobuf::Duration* RvSenderConfig::mutable_packet_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_packet_length();
  // @@protoc_insertion_point(field_mutable:rvpb.RvSenderConfig.packet_length)
  return _msg;
}
inline void RvSenderConfig::set_allocated_packet_length(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.packet_length_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvSenderConfig.packet_length)
}

// optional bool packet_interleaving = 3;
inline bool RvSenderConfig::has_packet_interleaving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RvSenderConfig::clear_packet_interleaving() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_interleaving_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RvSenderConfig::packet_interleaving() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.packet_interleaving)
  return _internal_packet_interleaving();
}
inline void RvSenderConfig::set_packet_interleaving(bool value) {
  _internal_set_packet_interleaving(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.packet_interleaving)
}
inline bool RvSenderConfig::_internal_packet_interleaving() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_interleaving_;
}
inline void RvSenderConfig::_internal_set_packet_interleaving(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_interleaving_ = value;
}

// optional .rvpb.RvFecEncoding fec_encoding = 4;
inline bool RvSenderConfig::has_fec_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RvSenderConfig::clear_fec_encoding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_encoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::rvpb::RvFecEncoding RvSenderConfig::fec_encoding() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.fec_encoding)
  return _internal_fec_encoding();
}
inline void RvSenderConfig::set_fec_encoding(::rvpb::RvFecEncoding value) {
  _internal_set_fec_encoding(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.fec_encoding)
}
inline ::rvpb::RvFecEncoding RvSenderConfig::_internal_fec_encoding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvFecEncoding>(_impl_.fec_encoding_);
}
inline void RvSenderConfig::_internal_set_fec_encoding(::rvpb::RvFecEncoding value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_encoding_ = value;
}

// optional uint32 fec_block_source_packets = 5;
inline bool RvSenderConfig::has_fec_block_source_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RvSenderConfig::clear_fec_block_source_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_source_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t RvSenderConfig::fec_block_source_packets() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.fec_block_source_packets)
  return _internal_fec_block_source_packets();
}
inline void RvSenderConfig::set_fec_block_source_packets(::uint32_t value) {
  _internal_set_fec_block_source_packets(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.fec_block_source_packets)
}
inline ::uint32_t RvSenderConfig::_internal_fec_block_source_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fec_block_source_packets_;
}
inline void RvSenderConfig::_internal_set_fec_block_source_packets(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_source_packets_ = value;
}

// optional uint32 fec_block_repair_packets = 6;
inline bool RvSenderConfig::has_fec_block_repair_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RvSenderConfig::clear_fec_block_repair_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_repair_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t RvSenderConfig::fec_block_repair_packets() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.fec_block_repair_packets)
  return _internal_fec_block_repair_packets();
}
inline void RvSenderConfig::set_fec_block_repair_packets(::uint32_t value) {
  _internal_set_fec_block_repair_packets(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.fec_block_repair_packets)
}
inline ::uint32_t RvSenderConfig::_internal_fec_block_repair_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fec_block_repair_packets_;
}
inline void RvSenderConfig::_internal_set_fec_block_repair_packets(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fec_block_repair_packets_ = value;
}

// optional .rvpb.RvLatencyTunerBackend latency_tuner_backend = 7;
inline bool RvSenderConfig::has_latency_tuner_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RvSenderConfig::clear_latency_tuner_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::rvpb::RvLatencyTunerBackend RvSenderConfig::latency_tuner_backend() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.latency_tuner_backend)
  return _internal_latency_tuner_backend();
}
inline void RvSenderConfig::set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value) {
  _internal_set_latency_tuner_backend(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.latency_tuner_backend)
}
inline ::rvpb::RvLatencyTunerBackend RvSenderConfig::_internal_latency_tuner_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvLatencyTunerBackend>(_impl_.latency_tuner_backend_);
}
inline void RvSenderConfig::_internal_set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = value;
}

// optional .rvpb.RvLatencyTunerProfile latency_tuner_profile = 8;
inline bool RvSenderConfig::has_latency_tuner_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RvSenderConfig::clear_latency_tuner_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::rvpb::RvLatencyTunerProfile RvSenderConfig::latency_tuner_profile() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.latency_tuner_profile)
  return _internal_latency_tuner_profile();
}
inline void RvSenderConfig::set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value) {
  _internal_set_latency_tuner_profile(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.latency_tuner_profile)
}
inline ::rvpb::RvLatencyTunerProfile RvSenderConfig::_internal_latency_tuner_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvLatencyTunerProfile>(_impl_.latency_tuner_profile_);
}
inline void RvSenderConfig::_internal_set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = value;
}

// optional .rvpb.RvResamplerBackend resampler_backend = 9;
inline bool RvSenderConfig::has_resampler_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void RvSenderConfig::clear_resampler_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::rvpb::RvResamplerBackend RvSenderConfig::resampler_backend() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.resampler_backend)
  return _internal_resampler_backend();
}
inline void RvSenderConfig::set_resampler_backend(::rvpb::RvResamplerBackend value) {
  _internal_set_resampler_backend(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.resampler_backend)
}
inline ::rvpb::RvResamplerBackend RvSenderConfig::_internal_resampler_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvResamplerBackend>(_impl_.resampler_backend_);
}
inline void RvSenderConfig::_internal_set_resampler_backend(::rvpb::RvResamplerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = value;
}

// optional .rvpb.RvResamplerProfile resampler_profile = 10;
inline bool RvSenderConfig::has_resampler_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void RvSenderConfig::clear_resampler_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::rvpb::RvResamplerProfile RvSenderConfig::resampler_profile() const {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.resampler_profile)
  return _internal_resampler_profile();
}
inline void RvSenderConfig::set_resampler_profile(::rvpb::RvResamplerProfile value) {
  _internal_set_resampler_profile(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:rvpb.RvSenderConfig.resampler_profile)
}
inline ::rvpb::RvResamplerProfile RvSenderConfig::_internal_resampler_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvResamplerProfile>(_impl_.resampler_profile_);
}
inline void RvSenderConfig::_internal_set_resampler_profile(::rvpb::RvResamplerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = value;
}

// optional .google.protobuf.Duration target_latency = 11;
inline bool RvSenderConfig::has_target_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvSenderConfig::_internal_target_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.target_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvSenderConfig::target_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.target_latency)
  return _internal_target_latency();
}
inline void RvSenderConfig::unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }
  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvSenderConfig.target_latency)
}
inline ::google::protobuf::Duration* RvSenderConfig::release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* released = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvSenderConfig::unsafe_arena_release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvSenderConfig.target_latency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvSenderConfig::_internal_mutable_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.target_latency_;
}
inline ::google::protobuf::Duration* RvSenderConfig::mutable_target_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Duration* _msg = _internal_mutable_target_latency();
  // @@protoc_insertion_point(field_mutable:rvpb.RvSenderConfig.target_latency)
  return _msg;
}
inline void RvSenderConfig::set_allocated_target_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvSenderConfig.target_latency)
}

// optional .google.protobuf.Duration latency_tolerance = 13;
inline bool RvSenderConfig::has_latency_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latency_tolerance_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvSenderConfig::_internal_latency_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.latency_tolerance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvSenderConfig::latency_tolerance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvSenderConfig.latency_tolerance)
  return _internal_latency_tolerance();
}
inline void RvSenderConfig::unsafe_arena_set_allocated_latency_tolerance(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latency_tolerance_);
  }
  _impl_.latency_tolerance_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvSenderConfig.latency_tolerance)
}
inline ::google::protobuf::Duration* RvSenderConfig::release_latency_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* released = _impl_.latency_tolerance_;
  _impl_.latency_tolerance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvSenderConfig::unsafe_arena_release_latency_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvSenderConfig.latency_tolerance)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = _impl_.latency_tolerance_;
  _impl_.latency_tolerance_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvSenderConfig::_internal_mutable_latency_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.latency_tolerance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.latency_tolerance_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.latency_tolerance_;
}
inline ::google::protobuf::Duration* RvSenderConfig::mutable_latency_tolerance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Duration* _msg = _internal_mutable_latency_tolerance();
  // @@protoc_insertion_point(field_mutable:rvpb.RvSenderConfig.latency_tolerance)
  return _msg;
}
inline void RvSenderConfig::set_allocated_latency_tolerance(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latency_tolerance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.latency_tolerance_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvSenderConfig.latency_tolerance)
}

// -------------------------------------------------------------------

// RvReceiverConfig

// repeated .rvpb.RvPacketEncoding packet_encodings = 1;
inline int RvReceiverConfig::_internal_packet_encodings_size() const {
  return _internal_packet_encodings().size();
}
inline int RvReceiverConfig::packet_encodings_size() const {
  return _internal_packet_encodings_size();
}
inline void RvReceiverConfig::clear_packet_encodings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_encodings_.Clear();
}
inline ::rvpb::RvPacketEncoding* RvReceiverConfig::mutable_packet_encodings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:rvpb.RvReceiverConfig.packet_encodings)
  return _internal_mutable_packet_encodings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>* RvReceiverConfig::mutable_packet_encodings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:rvpb.RvReceiverConfig.packet_encodings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_packet_encodings();
}
inline const ::rvpb::RvPacketEncoding& RvReceiverConfig::packet_encodings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.packet_encodings)
  return _internal_packet_encodings().Get(index);
}
inline ::rvpb::RvPacketEncoding* RvReceiverConfig::add_packet_encodings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::rvpb::RvPacketEncoding* _add = _internal_mutable_packet_encodings()->Add();
  // @@protoc_insertion_point(field_add:rvpb.RvReceiverConfig.packet_encodings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>& RvReceiverConfig::packet_encodings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:rvpb.RvReceiverConfig.packet_encodings)
  return _internal_packet_encodings();
}
inline const ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>&
RvReceiverConfig::_internal_packet_encodings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_encodings_;
}
inline ::google::protobuf::RepeatedPtrField<::rvpb::RvPacketEncoding>*
RvReceiverConfig::_internal_mutable_packet_encodings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.packet_encodings_;
}

// optional .rvpb.RvLatencyTunerBackend latency_tuner_backend = 2;
inline bool RvReceiverConfig::has_latency_tuner_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RvReceiverConfig::clear_latency_tuner_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::rvpb::RvLatencyTunerBackend RvReceiverConfig::latency_tuner_backend() const {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.latency_tuner_backend)
  return _internal_latency_tuner_backend();
}
inline void RvReceiverConfig::set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value) {
  _internal_set_latency_tuner_backend(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:rvpb.RvReceiverConfig.latency_tuner_backend)
}
inline ::rvpb::RvLatencyTunerBackend RvReceiverConfig::_internal_latency_tuner_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvLatencyTunerBackend>(_impl_.latency_tuner_backend_);
}
inline void RvReceiverConfig::_internal_set_latency_tuner_backend(::rvpb::RvLatencyTunerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_backend_ = value;
}

// optional .rvpb.RvLatencyTunerProfile latency_tuner_profile = 3;
inline bool RvReceiverConfig::has_latency_tuner_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RvReceiverConfig::clear_latency_tuner_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::rvpb::RvLatencyTunerProfile RvReceiverConfig::latency_tuner_profile() const {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.latency_tuner_profile)
  return _internal_latency_tuner_profile();
}
inline void RvReceiverConfig::set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value) {
  _internal_set_latency_tuner_profile(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:rvpb.RvReceiverConfig.latency_tuner_profile)
}
inline ::rvpb::RvLatencyTunerProfile RvReceiverConfig::_internal_latency_tuner_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvLatencyTunerProfile>(_impl_.latency_tuner_profile_);
}
inline void RvReceiverConfig::_internal_set_latency_tuner_profile(::rvpb::RvLatencyTunerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.latency_tuner_profile_ = value;
}

// optional .rvpb.RvResamplerBackend resampler_backend = 4;
inline bool RvReceiverConfig::has_resampler_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RvReceiverConfig::clear_resampler_backend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::rvpb::RvResamplerBackend RvReceiverConfig::resampler_backend() const {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.resampler_backend)
  return _internal_resampler_backend();
}
inline void RvReceiverConfig::set_resampler_backend(::rvpb::RvResamplerBackend value) {
  _internal_set_resampler_backend(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:rvpb.RvReceiverConfig.resampler_backend)
}
inline ::rvpb::RvResamplerBackend RvReceiverConfig::_internal_resampler_backend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvResamplerBackend>(_impl_.resampler_backend_);
}
inline void RvReceiverConfig::_internal_set_resampler_backend(::rvpb::RvResamplerBackend value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_backend_ = value;
}

// optional .rvpb.RvResamplerProfile resampler_profile = 5;
inline bool RvReceiverConfig::has_resampler_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RvReceiverConfig::clear_resampler_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::rvpb::RvResamplerProfile RvReceiverConfig::resampler_profile() const {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.resampler_profile)
  return _internal_resampler_profile();
}
inline void RvReceiverConfig::set_resampler_profile(::rvpb::RvResamplerProfile value) {
  _internal_set_resampler_profile(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:rvpb.RvReceiverConfig.resampler_profile)
}
inline ::rvpb::RvResamplerProfile RvReceiverConfig::_internal_resampler_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvResamplerProfile>(_impl_.resampler_profile_);
}
inline void RvReceiverConfig::_internal_set_resampler_profile(::rvpb::RvResamplerProfile value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resampler_profile_ = value;
}

// optional .google.protobuf.Duration target_latency = 6;
inline bool RvReceiverConfig::has_target_latency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_latency_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvReceiverConfig::_internal_target_latency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.target_latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvReceiverConfig::target_latency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.target_latency)
  return _internal_target_latency();
}
inline void RvReceiverConfig::unsafe_arena_set_allocated_target_latency(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }
  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvReceiverConfig.target_latency)
}
inline ::google::protobuf::Duration* RvReceiverConfig::release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvReceiverConfig::unsafe_arena_release_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvReceiverConfig.target_latency)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.target_latency_;
  _impl_.target_latency_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvReceiverConfig::_internal_mutable_target_latency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_latency_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.target_latency_;
}
inline ::google::protobuf::Duration* RvReceiverConfig::mutable_target_latency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_target_latency();
  // @@protoc_insertion_point(field_mutable:rvpb.RvReceiverConfig.target_latency)
  return _msg;
}
inline void RvReceiverConfig::set_allocated_target_latency(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_latency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_latency_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvReceiverConfig.target_latency)
}

// optional .google.protobuf.Duration latency_tolerance = 11;
inline bool RvReceiverConfig::has_latency_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latency_tolerance_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvReceiverConfig::_internal_latency_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.latency_tolerance_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvReceiverConfig::latency_tolerance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.latency_tolerance)
  return _internal_latency_tolerance();
}
inline void RvReceiverConfig::unsafe_arena_set_allocated_latency_tolerance(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latency_tolerance_);
  }
  _impl_.latency_tolerance_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvReceiverConfig.latency_tolerance)
}
inline ::google::protobuf::Duration* RvReceiverConfig::release_latency_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* released = _impl_.latency_tolerance_;
  _impl_.latency_tolerance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvReceiverConfig::unsafe_arena_release_latency_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvReceiverConfig.latency_tolerance)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Duration* temp = _impl_.latency_tolerance_;
  _impl_.latency_tolerance_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvReceiverConfig::_internal_mutable_latency_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.latency_tolerance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.latency_tolerance_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.latency_tolerance_;
}
inline ::google::protobuf::Duration* RvReceiverConfig::mutable_latency_tolerance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::google::protobuf::Duration* _msg = _internal_mutable_latency_tolerance();
  // @@protoc_insertion_point(field_mutable:rvpb.RvReceiverConfig.latency_tolerance)
  return _msg;
}
inline void RvReceiverConfig::set_allocated_latency_tolerance(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latency_tolerance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.latency_tolerance_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvReceiverConfig.latency_tolerance)
}

// optional .google.protobuf.Duration no_playback_timeout = 9;
inline bool RvReceiverConfig::has_no_playback_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.no_playback_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvReceiverConfig::_internal_no_playback_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.no_playback_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvReceiverConfig::no_playback_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.no_playback_timeout)
  return _internal_no_playback_timeout();
}
inline void RvReceiverConfig::unsafe_arena_set_allocated_no_playback_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.no_playback_timeout_);
  }
  _impl_.no_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvReceiverConfig.no_playback_timeout)
}
inline ::google::protobuf::Duration* RvReceiverConfig::release_no_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.no_playback_timeout_;
  _impl_.no_playback_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvReceiverConfig::unsafe_arena_release_no_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvReceiverConfig.no_playback_timeout)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.no_playback_timeout_;
  _impl_.no_playback_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvReceiverConfig::_internal_mutable_no_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.no_playback_timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.no_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.no_playback_timeout_;
}
inline ::google::protobuf::Duration* RvReceiverConfig::mutable_no_playback_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_no_playback_timeout();
  // @@protoc_insertion_point(field_mutable:rvpb.RvReceiverConfig.no_playback_timeout)
  return _msg;
}
inline void RvReceiverConfig::set_allocated_no_playback_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.no_playback_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.no_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvReceiverConfig.no_playback_timeout)
}

// optional .google.protobuf.Duration choppy_playback_timeout = 10;
inline bool RvReceiverConfig::has_choppy_playback_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.choppy_playback_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvReceiverConfig::_internal_choppy_playback_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.choppy_playback_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvReceiverConfig::choppy_playback_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvReceiverConfig.choppy_playback_timeout)
  return _internal_choppy_playback_timeout();
}
inline void RvReceiverConfig::unsafe_arena_set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.choppy_playback_timeout_);
  }
  _impl_.choppy_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvReceiverConfig.choppy_playback_timeout)
}
inline ::google::protobuf::Duration* RvReceiverConfig::release_choppy_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* released = _impl_.choppy_playback_timeout_;
  _impl_.choppy_playback_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvReceiverConfig::unsafe_arena_release_choppy_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvReceiverConfig.choppy_playback_timeout)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Duration* temp = _impl_.choppy_playback_timeout_;
  _impl_.choppy_playback_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvReceiverConfig::_internal_mutable_choppy_playback_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.choppy_playback_timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.choppy_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.choppy_playback_timeout_;
}
inline ::google::protobuf::Duration* RvReceiverConfig::mutable_choppy_playback_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Duration* _msg = _internal_mutable_choppy_playback_timeout();
  // @@protoc_insertion_point(field_mutable:rvpb.RvReceiverConfig.choppy_playback_timeout)
  return _msg;
}
inline void RvReceiverConfig::set_allocated_choppy_playback_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.choppy_playback_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.choppy_playback_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvReceiverConfig.choppy_playback_timeout)
}

// -------------------------------------------------------------------

// RvDeviceEncoding

// optional uint32 sample_rate = 1;
inline bool RvDeviceEncoding::has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RvDeviceEncoding::clear_sample_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t RvDeviceEncoding::sample_rate() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceEncoding.sample_rate)
  return _internal_sample_rate();
}
inline void RvDeviceEncoding::set_sample_rate(::uint32_t value) {
  _internal_set_sample_rate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceEncoding.sample_rate)
}
inline ::uint32_t RvDeviceEncoding::_internal_sample_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_;
}
inline void RvDeviceEncoding::_internal_set_sample_rate(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = value;
}

// optional .rvpb.RvChannelLayout channel_layout = 2;
inline bool RvDeviceEncoding::has_channel_layout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RvDeviceEncoding::clear_channel_layout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_layout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::rvpb::RvChannelLayout RvDeviceEncoding::channel_layout() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceEncoding.channel_layout)
  return _internal_channel_layout();
}
inline void RvDeviceEncoding::set_channel_layout(::rvpb::RvChannelLayout value) {
  _internal_set_channel_layout(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceEncoding.channel_layout)
}
inline ::rvpb::RvChannelLayout RvDeviceEncoding::_internal_channel_layout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvChannelLayout>(_impl_.channel_layout_);
}
inline void RvDeviceEncoding::_internal_set_channel_layout(::rvpb::RvChannelLayout value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_layout_ = value;
}

// optional .google.protobuf.Duration buffer_length = 3;
inline bool RvDeviceEncoding::has_buffer_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_length_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& RvDeviceEncoding::_internal_buffer_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.buffer_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& RvDeviceEncoding::buffer_length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceEncoding.buffer_length)
  return _internal_buffer_length();
}
inline void RvDeviceEncoding::unsafe_arena_set_allocated_buffer_length(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.buffer_length_);
  }
  _impl_.buffer_length_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rvpb.RvDeviceEncoding.buffer_length)
}
inline ::google::protobuf::Duration* RvDeviceEncoding::release_buffer_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.buffer_length_;
  _impl_.buffer_length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* RvDeviceEncoding::unsafe_arena_release_buffer_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:rvpb.RvDeviceEncoding.buffer_length)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.buffer_length_;
  _impl_.buffer_length_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* RvDeviceEncoding::_internal_mutable_buffer_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.buffer_length_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.buffer_length_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.buffer_length_;
}
inline ::google::protobuf::Duration* RvDeviceEncoding::mutable_buffer_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_buffer_length();
  // @@protoc_insertion_point(field_mutable:rvpb.RvDeviceEncoding.buffer_length)
  return _msg;
}
inline void RvDeviceEncoding::set_allocated_buffer_length(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.buffer_length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.buffer_length_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:rvpb.RvDeviceEncoding.buffer_length)
}

// optional uint32 track_count = 4;
inline bool RvDeviceEncoding::has_track_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RvDeviceEncoding::clear_track_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.track_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RvDeviceEncoding::track_count() const {
  // @@protoc_insertion_point(field_get:rvpb.RvDeviceEncoding.track_count)
  return _internal_track_count();
}
inline void RvDeviceEncoding::set_track_count(::uint32_t value) {
  _internal_set_track_count(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:rvpb.RvDeviceEncoding.track_count)
}
inline ::uint32_t RvDeviceEncoding::_internal_track_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.track_count_;
}
inline void RvDeviceEncoding::_internal_set_track_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.track_count_ = value;
}

// -------------------------------------------------------------------

// RvPacketEncoding

// uint32 encoding_id = 1;
inline void RvPacketEncoding::clear_encoding_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoding_id_ = 0u;
}
inline ::uint32_t RvPacketEncoding::encoding_id() const {
  // @@protoc_insertion_point(field_get:rvpb.RvPacketEncoding.encoding_id)
  return _internal_encoding_id();
}
inline void RvPacketEncoding::set_encoding_id(::uint32_t value) {
  _internal_set_encoding_id(value);
  // @@protoc_insertion_point(field_set:rvpb.RvPacketEncoding.encoding_id)
}
inline ::uint32_t RvPacketEncoding::_internal_encoding_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encoding_id_;
}
inline void RvPacketEncoding::_internal_set_encoding_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoding_id_ = value;
}

// uint32 sample_rate = 2;
inline void RvPacketEncoding::clear_sample_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = 0u;
}
inline ::uint32_t RvPacketEncoding::sample_rate() const {
  // @@protoc_insertion_point(field_get:rvpb.RvPacketEncoding.sample_rate)
  return _internal_sample_rate();
}
inline void RvPacketEncoding::set_sample_rate(::uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:rvpb.RvPacketEncoding.sample_rate)
}
inline ::uint32_t RvPacketEncoding::_internal_sample_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sample_rate_;
}
inline void RvPacketEncoding::_internal_set_sample_rate(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_rate_ = value;
}

// .rvpb.RvSampleFormat sample_format = 3;
inline void RvPacketEncoding::clear_sample_format() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_format_ = 0;
}
inline ::rvpb::RvSampleFormat RvPacketEncoding::sample_format() const {
  // @@protoc_insertion_point(field_get:rvpb.RvPacketEncoding.sample_format)
  return _internal_sample_format();
}
inline void RvPacketEncoding::set_sample_format(::rvpb::RvSampleFormat value) {
  _internal_set_sample_format(value);
  // @@protoc_insertion_point(field_set:rvpb.RvPacketEncoding.sample_format)
}
inline ::rvpb::RvSampleFormat RvPacketEncoding::_internal_sample_format() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvSampleFormat>(_impl_.sample_format_);
}
inline void RvPacketEncoding::_internal_set_sample_format(::rvpb::RvSampleFormat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sample_format_ = value;
}

// .rvpb.RvChannelLayout channel_layout = 4;
inline void RvPacketEncoding::clear_channel_layout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_layout_ = 0;
}
inline ::rvpb::RvChannelLayout RvPacketEncoding::channel_layout() const {
  // @@protoc_insertion_point(field_get:rvpb.RvPacketEncoding.channel_layout)
  return _internal_channel_layout();
}
inline void RvPacketEncoding::set_channel_layout(::rvpb::RvChannelLayout value) {
  _internal_set_channel_layout(value);
  // @@protoc_insertion_point(field_set:rvpb.RvPacketEncoding.channel_layout)
}
inline ::rvpb::RvChannelLayout RvPacketEncoding::_internal_channel_layout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::rvpb::RvChannelLayout>(_impl_.channel_layout_);
}
inline void RvPacketEncoding::_internal_set_channel_layout(::rvpb::RvChannelLayout value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_layout_ = value;
}

// optional uint32 track_count = 5;
inline bool RvPacketEncoding::has_track_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RvPacketEncoding::clear_track_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.track_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t RvPacketEncoding::track_count() const {
  // @@protoc_insertion_point(field_get:rvpb.RvPacketEncoding.track_count)
  return _internal_track_count();
}
inline void RvPacketEncoding::set_track_count(::uint32_t value) {
  _internal_set_track_count(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:rvpb.RvPacketEncoding.track_count)
}
inline ::uint32_t RvPacketEncoding::_internal_track_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.track_count_;
}
inline void RvPacketEncoding::_internal_set_track_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.track_count_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace rvpb


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::rvpb::RvLogEntry_Level> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvLogEntry_Level>() {
  return ::rvpb::RvLogEntry_Level_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvDeviceType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvDeviceType>() {
  return ::rvpb::RvDeviceType_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvInterface> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvInterface>() {
  return ::rvpb::RvInterface_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvSampleFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvSampleFormat>() {
  return ::rvpb::RvSampleFormat_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvChannelLayout> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvChannelLayout>() {
  return ::rvpb::RvChannelLayout_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvFecEncoding> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvFecEncoding>() {
  return ::rvpb::RvFecEncoding_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvLatencyTunerBackend> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvLatencyTunerBackend>() {
  return ::rvpb::RvLatencyTunerBackend_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvLatencyTunerProfile> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvLatencyTunerProfile>() {
  return ::rvpb::RvLatencyTunerProfile_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvResamplerBackend> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvResamplerBackend>() {
  return ::rvpb::RvResamplerBackend_descriptor();
}
template <>
struct is_proto_enum<::rvpb::RvResamplerProfile> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::rvpb::RvResamplerProfile>() {
  return ::rvpb::RvResamplerProfile_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_driver_5fprotocol_2eproto_2epb_2eh
